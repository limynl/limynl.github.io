<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[xiongzhanghao]]></title>
    <url>%2F2018%2F05%2F22%2Fxiongzhanghao%2F</url>
    <content type="text"><![CDATA[熊掌号的意义百度熊掌号是内容和服务提供者入驻百度生态的实名账号，致力于帮助内容和服务提供者方便、快捷、高效地连接百度用户，并充分利用搜索生态开放的优势，获得流量和沉淀用户，实现自身价值的快速增长。 熊掌号的目的：1、建站开发流程繁杂，推广营销成本高；2、互联网平台分散，站长需要同时维护多个平台，各平台的用户不能互通，运营成本较高；3、传统的搜索仅能获取流量，无法有效留存并运营用户；同时将搜索时代由PC向移动转变，从站长角度发展搜索生态。 熊掌号的作用：1、为资源方带来的收益：①、品牌赋能：资源方可以将优质内容及服务全部提交到熊掌号，统一用户端品牌认知。同时，在搜索引擎上的各个地方，熊掌号的主页、搜索结果页、第三方落地页都强调合作方品牌。熊掌号支持将官网、百家号、官方APP、官方微博等全部内容和服务链接到熊掌号，有利于用户对品牌认知的统一。例如展示内容提供者的名称、Logo等。 ②、流量赋能：通过熊掌号，百度启动了全新的搜索资源索引、排序机制和全新的阿拉丁开放机制，这种新的流量分发机制，使内容资源更加开放。例如，为用户推荐相关的其他内容，引导用户。 ③、运营赋能：从用户沉淀到粉丝积累、再到营销变现，熊掌号将形成完整的闭环生态，为内容和服务提供者带来更多种的粉丝互动手段和更多元的营销推广模式。例如，关注熊掌号，与内容提供者进行发送消息、互动等。 ④、技术赋能：基于熊掌号，百度将开放能力给资源方，帮助资源方提升自身服务转化率。如账号登录、支付能力、运营能力、端能力、AI能力等。 2、为搜索用户带来的收益：①、用户在百度获得的内容将更加丰富多彩；②、多种方式保证用户权益不受侵害；③、满足了用户对优质资源内容、服务的持续性需求。 熊掌号的发展：百度通过熊掌号将用户和资源提供者进行结合，使用户和账号运营者之间产生关联进而实现营销的目的，帮助内容和服务提供者获得更多的流量和用户，改变整个搜索生态的模式，相信百度在这条路上会越走越远。用科技让复杂的世界变得更简单，这是百度的新愿景，相信熊掌号必将开启搜索新时代。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法总结]]></title>
    <url>%2F2018%2F04%2F03%2Fcommon-sorting-summary%2F</url>
    <content type="text"><![CDATA[前言排序是数据处理中经常使用的一种操作，其主要目的是便于查找。根据不同角度，可以对排序进行分类，例如是否建立在关键码比较的基础上，将排序方法分为基于比较的排序和不基于比较的排序。这里根据基于比较的排序方法，大致分为插入排序、交换排序、选择排序、归并排序等四类，其主要就是通过关键码之间的比较和记录的移动这两种操作来实现的。 插入排序主要思想：每次将一个待排序的记录按其关键码的大小插入到一个已经排好序的有序序列中，直到全部记录排好序。 直接插入排序思路依次将待排序序列中的每一个记录插入到一个已排好序的序列中，直到全部记录排好序。 实现过程 将整个待排序的记录序列划分为有序区和无序区，初始时有序区为待排序记录中的第一个记录，无序区 包括所有剩余待排序的记录; 将无序区的第一个记录插入到有序区的合适位置，从而使有序区减少一个记录，有序区增加一个记录; 重复步骤2，直到无序区没有记录为止。 代码实现123456789101112131415161718/** * 直接插入排序 * @param arr 待排序的数组序列 */public static void insertSort(int arr[])&#123; int temp = 0; for(int i = 1; i &lt;= arr.length - 1; i++)&#123; //暂存带插入记录 temp = arr[i]; int j = 0; //寻找插入位置 for(j = i - 1; temp &lt; arr[j]; j--)&#123; //记录后移 arr[j + 1] = arr[j]; &#125; arr[j + 1] = temp; &#125;&#125; 总结 直接插入排序是一种稳定的排序方法； 当序列中的记录基本有序或者待排序记录较少是，它是最佳的排序方法； 当待排序中的记录个数较多时，记录将会进行大量的比较和移动，此时性能较差。 希尔排序思路它是对直接插入排序的一种改进，先将整个待排序记录序列分割成若干个子序列，在子序列内分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序。 实现过程 假设待排序的记录为n个，先取整数d &lt; n，将所有相距为d的记录构成一组，从而将整个待排序记录序列分割成d个子序列； 对每个子序列分别进行直接插入排序； 缩小间隔d，重复上述过程，直到最后d=1。 实现代码123456789101112131415161718192021/** * 希尔排序 * @param arr 待排序的数组序列 */public static void shellSort(int arr[])&#123; //暂存待插入记录 int key = 0; //对增量d进行划分，直到d=1为止 for(int d = arr.length / 2; d &gt;= 1; d = d / 2)&#123; //在整个序列中，前d个记录分别是d个子序列中的第一个记录，所以从(d + 1)个位置开始进行插入 for(int i = d + 1; i &lt;= arr.length - 1; i++)&#123; key = arr[i]; int j = 0; //对每个子序列进行直接插入排序，因为每个子序列中记录之间的间隔为d，因此每次插入时向前跳跃d个位置 for(j = i - d; j &gt; 0 &amp;&amp; key &lt; arr[j]; j = j - d)&#123; arr[j + d] = arr[j]; &#125; arr[j + d] = key; &#125; &#125;&#125; 总结 希尔排序是一种不稳定的排序方法； 对于增量d的设计，要使得最后一个增量必须等于1，即将所有记录放到一组进行一次直接插入排序，从而使得最终的所有记录均按关键码有序排列。 交换排序主要思想：在待排序序列中选两个记录，将它们进行比较，如果反序则交换它们的位置。 冒泡排序]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解AVL树]]></title>
    <url>%2F2018%2F03%2F30%2Fdetailed-explanation-avl%2F</url>
    <content type="text"><![CDATA[前言在BST树中，查找性能在O(logn)~O(n)之间，如果该树为右斜树，则查找效率为O(n)，其查找效率取决于二叉查找树的形态，而构造一颗均匀的二叉查找树与结点插入的次序有关，因此需要找到一种动态平衡的方法，对于任意给定的关键码序列都能构造一颗形态均匀的、平衡的二叉查找树，即AVL树(平衡二叉查找树) 相关知识AVL树特点 AVL树是一颗二叉查找树，任一个根节点的左节点小于根节点，右节点大于根节点 根节点的右子树和左子树的深度最多相差1 说明： &nbsp;&nbsp;&nbsp;&nbsp;1、这里规定空二叉树的深度为0; &nbsp;&nbsp;&nbsp;&nbsp;2、节点的层数为1，树的深度为所有结点的最大层数。 平衡因子 节点的平衡因子是该节点左子树的深度与右子树的深度之差 在AVL树中，任一节点的平衡因子的绝对值&lt;=1时，该树是平衡的，否则不是平衡的 最小不平衡子树 在平衡二叉树的构造过程中，以距离插入节点最近的且平衡因子的绝对值大于1的节点为根的子树 存在的问题在构造AVL树或者对AVL树进行插入、删除节点时，可能导致AVL树失去平衡(即某节点的平衡因子的绝对值大于1)，导致AVL树失衡概括起来共有4种情况：LL(左左)、LR(左右)、RR(右右)、RL(右左)，如下图所示。但是通过旋转能使其恢复平衡。 LL型调整过程 插入或删除一个节点后，根节点的左子树的左子树还有非空子节点，导致根节点k2的平衡因子为2，此时AVL树不平衡。可以通过一次左旋转让AVL树恢复平衡。如上图所示，以k2为起点绕k1顺时针旋转，但是k2与k1的右子树Y冲突，此时以旋转优先，使k2为k1的右子树，Y为k2的左子树。此时该AVL树就恢复平衡了。 代码实现12345678910111213141516171819/** * LL：左左对应的情况——左单旋转 * @param k2 最小不平衡子树的根节点 * @return 旋转后的根节点 */private AVLTreeNode&lt;T&gt; leftLeftRotation(AVLTreeNode&lt;T&gt; k2)&#123; AVLTreeNode&lt;T&gt; k1; //调整各节点的左右子树 k1 = k2.leftNode; k2.leftNode = k1.rightNode; k1.rightNode = k2; //更新相应结点的层数，+1的原因就是空二叉树的深度为0 k2.height = max(getNodeHeight(k2.leftNode), getNodeHeight(k2.rightNode)) + 1; k1.height = max(getNodeHeight(k1.leftNode), k2.height) + 1; return k1;&#125; RR型调整过程 插入或删除一个节点后，根节点的右子树的右子树还有非空子节点，导致根节点k1的平衡因子为-2，此时AVL树不平衡。可以通过一次右旋转让AVL树恢复平衡。如上图所示，以k1为起点绕k2逆时针旋转，但是k1与k2的左子树Y冲突，此时以旋转优先，使k1为k2的左子树，Y为k1的右子树。此时该AVL树就恢复平衡了。 代码实现123456789101112131415161718/** * RR：右右对应的情况——右单旋转 * @param k1 最小不平衡子树的根节点 * @return 旋转之后的根节点 */private AVLTreeNode&lt;T&gt; rightRightRotation(AVLTreeNode&lt;T&gt; k1)&#123; AVLTreeNode&lt;T&gt; k2; //调整相应结点的左右子树 k2 = k1.rightNode; k1.rightNode = k2.leftNode; k2.leftNode = k1; //更新相应结点的层数 k1.height = max(getNodeHeight(k1.leftNode), getNodeHeight(k1.rightNode)) + 1; k2.height = max(getNodeHeight(k2.rightNode), k1.height) + 1; return k2;&#125; LR型调整过程 插入或删除一个节点后，根节点的左子树的右子树还有非空子节点，导致根节点k3的平衡因子为2，此时该AVL树不平衡。可以通过右左双旋转让AVL树恢复平衡。如上图所示，第一次旋转：以k1为起点绕k2逆时针旋转，但是k1与k2的左子树Y冲突，此时以旋转优先，使k1为k2的左子树，Y为k1的右子树，此时应该告知树的其余部分该变化，因此k3的左子树为k2。第二次旋转：经过第一次的旋转，可以发现此时该AVL树符合LL的情况，因此以k3为起点绕k2顺时针旋转，但是k3与k2的右子树Z冲突，以旋转优先，使k3为k2的右子树，Z为k3的左子树。此时该AVL树就恢复平衡了。总结：该种情况其实就是经过两个旋转即可完成，第一次对k1进行RR旋转，第二次对k3进行LL旋转 代码实现1234567891011/** * LR：左右对应的情况(左双旋转) * @param k3 最小不平衡子树的根节点 * @return 旋转之后的根节点 */private AVLTreeNode&lt;T&gt; leftRightRotation(AVLTreeNode&lt;T&gt; k3)&#123; //对k1进行RR旋转，将旋转之后的根节点k2成为k3的左子树 k3.leftNode = rightRightRotation(k3.leftNode); //对k3进行LL旋转 return leftLeftRotation(k3);&#125; RL型调整过程 插入或删除一个节点后，根节点的左子树的右子树还有非空子节点，导致根节点k1的平衡因子为-2，此时该AVL树不平衡。可以通过左右双旋转让AVL树恢复平衡。如上图所示，第一次旋转：以k3为起点绕k2顺时针旋转，但是k3与k2的左子树Z冲突，此时以旋转优先，使k3为k2的左子树，Z为k3的右子树，此时应该告知树的其余部分该变化，因此k1的右子树为k2。第二次旋转：经过第一次的旋转，可以发现此时该AVL树符合RR的情况，因此以k1为起点绕k2逆时针旋转，但是k1与k2的左子树Y冲突，以旋转优先，使k1为k2的左子树，Y为k1的右子树。此时该AVL树就是平衡的了。总结：该种情况其实就是经过两个旋转即可完成，第一次对k3进行LL旋转，第二次对k1进行RR旋转 代码实现1234567891011/** * RL：右左对应的情况(右双旋转) * @param k1 最小不平衡子树的根节点 * @return 旋转之后的根节点 */private AVLTreeNode&lt;T&gt; rightLeftRotation(AVLTreeNode&lt;T&gt; k1)&#123; //对k3进行RR旋转，将旋转之后的根节点k2成为k1的右子树 k1.rightNode = leftLeftRotation(k1.rightNode); //直接对k1进行RR旋转 return rightRightRotation(k1);&#125; 注意：在旋转过程中由于旋转引起的局部变化，应该通知树的其余部分该变化。例如，在RL情况的第一次旋转中就应该通知k1改变它的右子树的指向，由原先指向k3改为现在的k2，如果忘记这一点的话，那么树的结构将会被破坏，即k1的右子树就不可访问了。 相关操作 完整的代码后文将会一并给出 插入操作有了前面几种情况的讨论，那么AVL树中节点的插入，无非就是插入节点后，对相应的情况进行处理:123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 将节点插入AVL树中，并返回根节点 * @param rootNode AVL树的根节点 * @param value 即将插入节点的数据域 * @return */private AVLTreeNode&lt;T&gt; insertNode(AVLTreeNode&lt;T&gt; rootNode, T value)&#123; //AVL树根节点为空 if(rootNode == null)&#123; rootNode = new AVLTreeNode&lt;T&gt;(value); &#125;else&#123; int result = value.compareTo(rootNode.value); if(result &lt; 0)&#123; //将待插入节点插到rootNode的左子树上 rootNode.leftNode = insertNode(rootNode.leftNode, value); //插入节点后，若AVL树失去平衡，则进行相应的调节 if(getNodeHeight(rootNode.leftNode) - getNodeHeight(rootNode.rightNode) == 2)&#123; if(value.compareTo(rootNode.leftNode.value) &lt; 0)&#123; //LL对应的情况，进行左单旋转 rootNode = leftLeftRotation(rootNode); &#125;else&#123; //LR对应的情况，进行左双旋转 rootNode = leftRightRotation(rootNode); &#125; &#125; &#125;else if(result &gt; 0)&#123; //将待插入节点插到rootNode的右子树上 rootNode.rightNode = insertNode(rootNode.rightNode, value); //插入节点后，若AVL树失去平衡，则进行相应调节 if(getNodeHeight(rootNode.rightNode) - getNodeHeight(rootNode.leftNode) == 2)&#123; if(value.compareTo(rootNode.rightNode.value) &gt; 0)&#123; //RR对应的情况，进行右单旋转 rootNode = rightRightRotation(rootNode); &#125;else&#123; //RL对应的情况，进行右双旋转 rootNode = rightLeftRotation(rootNode); &#125; &#125; &#125;else&#123; System.out.println(&quot;插入失败，不允许添加两个相同的节点！&quot;); &#125; &#125; rootNode.height = max(getNodeHeight(rootNode.leftNode), getNodeHeight(rootNode.rightNode)) + 1; return rootNode;&#125; 删除操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 删除AVL树上的一个节点 * @param rootNode 根节点 * @param z 待删除节点 * @return 跟节点 */private AVLTreeNode&lt;T&gt; deleteNode(AVLTreeNode&lt;T&gt; rootNode, AVLTreeNode&lt;T&gt; z) &#123; //根节点为空 if (rootNode == null || z == null) &#123; return null; &#125; int result = z.value.compareTo(rootNode.value); if (result &lt; 0) &#123; //待删除的节点在rootNode的左子树中 rootNode.leftNode = deleteNode(rootNode.leftNode, z); //删除节点后，若AVL树失去平衡，则进行相应调节 if (getNodeHeight(rootNode.rightNode) - getNodeHeight(rootNode.leftNode) == 2) &#123; AVLTreeNode&lt;T&gt; r = rootNode.rightNode; if (getNodeHeight(r.leftNode) &gt; getNodeHeight(r.rightNode)) &#123; rootNode = rightLeftRotation(rootNode); &#125; else &#123; rootNode = rightRightRotation(rootNode); &#125; &#125; &#125; else if (result &gt; 0) &#123; //待删除的节点在rootNode的右子树中 rootNode.rightNode = deleteNode(rootNode.rightNode, z); //删除节点后，若AVL树失去平衡，则进行相应调节 if (getNodeHeight(rootNode.leftNode) - getNodeHeight(rootNode.rightNode) == 2) &#123; AVLTreeNode&lt;T&gt; l = rootNode.leftNode; if (getNodeHeight(l.rightNode) &gt; getNodeHeight(l.leftNode)) &#123; rootNode = leftRightRotation(rootNode); &#125; else &#123; rootNode = leftLeftRotation(rootNode); &#125; &#125; &#125; else &#123; // tree的左右孩子都非空 if ((rootNode.leftNode != null) &amp;&amp; (rootNode.rightNode != null)) &#123; if (getNodeHeight(rootNode.leftNode) &gt; getNodeHeight(rootNode.rightNode)) &#123; AVLTreeNode&lt;T&gt; max = maxNode(rootNode.leftNode); rootNode.value = max.value; rootNode.leftNode = deleteNode(rootNode.leftNode, max); &#125;else&#123; AVLTreeNode&lt;T&gt; min = maxNode(rootNode.rightNode); rootNode.value = min.value; rootNode.rightNode = deleteNode(rootNode.rightNode, min); &#125; &#125;else&#123; rootNode = (rootNode.leftNode != null) ? rootNode.leftNode : rootNode.rightNode; &#125; &#125; return rootNode;&#125; 完整源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347public class AVLTree&lt;T extends Comparable&lt;T&gt;&gt; &#123; /** * 根节点 */ private AVLTreeNode&lt;T&gt; root; public AVLTree() &#123; root = null; &#125; /** * 获取节点的高度 * 说明： * 1、空二叉树的深度为0 * 2、根节点的层数为1，树的深度为所有结点的最大层数 */ private int getNodeHeight(AVLTreeNode&lt;T&gt; treeNode) &#123; if (treeNode == null) &#123; return 0; &#125; return treeNode.height; &#125; /** * 获取根节点的高度 */ public int height() &#123; return getNodeHeight(root); &#125; /** * 比较两个值的大小 */ private int max(int a, int b) &#123; return a &gt; b ? a : b; &#125; /** * LL：左左对应的情况——左单旋转 * * @param k2 最小不平衡子树的根节点 * @return 旋转后的根节点 */ private AVLTreeNode&lt;T&gt; leftLeftRotation(AVLTreeNode&lt;T&gt; k2) &#123; AVLTreeNode&lt;T&gt; k1; //将k2的左子树暂存 k1 = k2.leftNode; k2.leftNode = k1.rightNode; k1.rightNode = k2; //更新相应结点的层数 k2.height = max(getNodeHeight(k2.leftNode), getNodeHeight(k2.rightNode)) + 1; k1.height = max(getNodeHeight(k1.leftNode), k2.height) + 1; return k1; &#125; /** * RR：右右对应的情况——右单旋转 * * @param k1 最小不平衡子树的根节点 * @return 旋转之后的根节点 */ private AVLTreeNode&lt;T&gt; rightRightRotation(AVLTreeNode&lt;T&gt; k1) &#123; AVLTreeNode&lt;T&gt; k2; k2 = k1.rightNode; k1.rightNode = k2.leftNode; k2.leftNode = k1; //更新相应结点的层数 k1.height = max(getNodeHeight(k1.leftNode), getNodeHeight(k1.rightNode)) + 1; k2.height = max(getNodeHeight(k2.rightNode), k1.height) + 1; return k2; &#125; /** * LR：左右对应的情况(左双旋转) * * @param k3 最小不平衡子树的根节点 * @return 旋转之后的根节点 */ private AVLTreeNode&lt;T&gt; leftRightRotation(AVLTreeNode&lt;T&gt; k3) &#123; //对k1进行RR旋转，将旋转之后的根节点k2成为k3的左子树 k3.leftNode = rightRightRotation(k3.leftNode); //对k3进行LL旋转 return leftLeftRotation(k3); &#125; /** * RL：右左对应的情况(右双旋转) * * @param k1 最小不平衡子树的根节点 * @return 旋转之后的根节点 */ private AVLTreeNode&lt;T&gt; rightLeftRotation(AVLTreeNode&lt;T&gt; k1) &#123; k1.rightNode = leftLeftRotation(k1.rightNode); return rightRightRotation(k1); &#125; /** * 将节点插入AVL树中，并返回根节点 * * @param rootNode AVL树的根节点 * @param value 即将插入节点的数据域 * @return */ private AVLTreeNode&lt;T&gt; insertNode(AVLTreeNode&lt;T&gt; rootNode, T value) &#123; //AVL树根节点为空 if (rootNode == null) &#123; rootNode = new AVLTreeNode&lt;T&gt;(value); &#125; else &#123; int result = value.compareTo(rootNode.value); if (result &lt; 0) &#123; //将待插入节点插到rootNode的左子树上 rootNode.leftNode = insertNode(rootNode.leftNode, value); //插入节点后，若AVL树失去平衡，则进行相应的调节 if (getNodeHeight(rootNode.leftNode) - getNodeHeight(rootNode.rightNode) == 2) &#123; if (value.compareTo(rootNode.leftNode.value) &lt; 0) &#123; //LL对应的情况，进行左单旋转 rootNode = leftLeftRotation(rootNode); &#125; else &#123; //LR对应的情况，进行左双旋转 rootNode = leftRightRotation(rootNode); &#125; &#125; &#125; else if (result &gt; 0) &#123; //将待插入节点插到rootNode的右子树上 rootNode.rightNode = insertNode(rootNode.rightNode, value); //插入节点后，若AVL树失去平衡，则进行相应调节 if (getNodeHeight(rootNode.rightNode) - getNodeHeight(rootNode.leftNode) == 2) &#123; if (value.compareTo(rootNode.rightNode.value) &gt; 0) &#123; //RR对应的情况，进行右单旋转 rootNode = rightRightRotation(rootNode); &#125; else &#123; //RL对应的情况，进行右双旋转 rootNode = rightLeftRotation(rootNode); &#125; &#125; &#125; else &#123; System.out.println(&quot;插入失败，不允许添加两个相同的节点！&quot;); &#125; &#125; rootNode.height = max(getNodeHeight(rootNode.leftNode), getNodeHeight(rootNode.rightNode)) + 1; return rootNode; &#125; public void insertNode(T value) &#123; root = insertNode(root, value); &#125; /** * 删除AVL树上的一个节点 * * @param rootNode 根节点 * @param z 待删除节点 * @return 跟节点 */ private AVLTreeNode&lt;T&gt; deleteNode(AVLTreeNode&lt;T&gt; rootNode, AVLTreeNode&lt;T&gt; z) &#123; //根节点为空 if (rootNode == null || z == null) &#123; return null; &#125; int result = z.value.compareTo(rootNode.value); if (result &lt; 0) &#123; //待删除的节点在rootNode的左子树中 rootNode.leftNode = deleteNode(rootNode.leftNode, z); //删除节点后，若AVL树失去平衡，则进行相应调节 if (getNodeHeight(rootNode.rightNode) - getNodeHeight(rootNode.leftNode) == 2) &#123; AVLTreeNode&lt;T&gt; r = rootNode.rightNode; if (getNodeHeight(r.leftNode) &gt; getNodeHeight(r.rightNode)) &#123; rootNode = rightLeftRotation(rootNode); &#125; else &#123; rootNode = rightRightRotation(rootNode); &#125; &#125; &#125; else if (result &gt; 0) &#123; //待删除的节点在rootNode的右子树中 rootNode.rightNode = deleteNode(rootNode.rightNode, z); //删除节点后，若AVL树失去平衡，则进行相应调节 if (getNodeHeight(rootNode.leftNode) - getNodeHeight(rootNode.rightNode) == 2) &#123; AVLTreeNode&lt;T&gt; l = rootNode.leftNode; if (getNodeHeight(l.rightNode) &gt; getNodeHeight(l.leftNode)) &#123; rootNode = leftRightRotation(rootNode); &#125; else &#123; rootNode = leftLeftRotation(rootNode); &#125; &#125; &#125; else &#123; // tree的左右孩子都非空 if ((rootNode.leftNode != null) &amp;&amp; (rootNode.rightNode != null)) &#123; if (getNodeHeight(rootNode.leftNode) &gt; getNodeHeight(rootNode.rightNode)) &#123; AVLTreeNode&lt;T&gt; max = maxNode(rootNode.leftNode); rootNode.value = max.value; rootNode.leftNode = deleteNode(rootNode.leftNode, max); &#125;else&#123; AVLTreeNode&lt;T&gt; min = maxNode(rootNode.rightNode); rootNode.value = min.value; rootNode.rightNode = deleteNode(rootNode.rightNode, min); &#125; &#125;else&#123; rootNode = (rootNode.leftNode != null) ? rootNode.leftNode : rootNode.rightNode; &#125; &#125; return rootNode; &#125; public void deleteNode(T value) &#123; AVLTreeNode&lt;T&gt; node; //查找要删除的节点是否存在 if ((node = searchNode(root, value)) != null)&#123; root = deleteNode(root, node); &#125;else&#123; System.out.println(&quot;AVL树中不存在该节点&quot;); &#125; &#125; /** * 查找AVL树上的值最大的节点 * @param rootNode AVL树的根节点 * @return */ private AVLTreeNode&lt;T&gt; maxNode(AVLTreeNode&lt;T&gt; rootNode) &#123; //AVL树不存在 if (rootNode == null) &#123; return null; &#125; //AVL实质就是二叉查找树，因此最大节点在树的最右边 while (rootNode.rightNode != null) &#123; rootNode = rootNode.rightNode; &#125; return rootNode; &#125; public T maxNode()&#123; AVLTreeNode&lt;T&gt; node = maxNode(root); if(node != null)&#123; return node.value; &#125; return null; &#125; /** * 查找AVL树上的值最小的节点 * @param rootNode AVL树的根节点 * @return */ private AVLTreeNode&lt;T&gt; minNode(AVLTreeNode&lt;T&gt; rootNode)&#123; //AVL树不存在 if(rootNode == null)&#123; return null; &#125; //AVL树实质上就是二叉查找树，因此最大节点在树的最左边 while(rootNode.leftNode != null)&#123; rootNode = rootNode.leftNode; &#125; return rootNode; &#125; public T minNode()&#123; AVLTreeNode&lt;T&gt; node = minNode(root); if(node != null)&#123; return node.value; &#125; return null; &#125; /** * 查找AVL树中指定value的节点 * @param rootNode AVL树的根节点 * @param value 要查找节点的value * @return */ private AVLTreeNode&lt;T&gt; searchNode(AVLTreeNode&lt;T&gt; rootNode, T value)&#123; if(rootNode == null)&#123; return null; &#125; int result = value.compareTo(rootNode.value); if(result &lt; 0)&#123; return searchNode(rootNode.leftNode, value); &#125;else if(result &gt; 0)&#123; return searchNode(rootNode.rightNode, value); &#125;else&#123; return rootNode; &#125; &#125; public AVLTreeNode&lt;T&gt; searchNode(T value)&#123; return searchNode(root, value); &#125; /** * 前序遍历AVL树 */ private void preOrder(AVLTreeNode&lt;T&gt; rootNode) &#123; if (rootNode == null) &#123; return; &#125; System.out.print(rootNode.value + &quot;, &quot;); preOrder(rootNode.leftNode); preOrder(rootNode.rightNode); &#125; public void preOrder() &#123; preOrder(root); &#125; /** * AVL树的节点内部类 */ private static class AVLTreeNode&lt;T extends Comparable&lt;T&gt;&gt; &#123; /** * 节点的数据域 */ T value; /** * 左孩子 */ AVLTreeNode&lt;T&gt; leftNode; /** * 右孩子 */ AVLTreeNode&lt;T&gt; rightNode; /** * 该结点的深度 */ int height; public AVLTreeNode(T value) &#123; this(value, null, null); &#125; public AVLTreeNode(T value, AVLTreeNode&lt;T&gt; leftNode, AVLTreeNode&lt;T&gt; rightNode) &#123; this.value = value; this.leftNode = leftNode; this.rightNode = rightNode; this.height = 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无题]]></title>
    <url>%2F2017%2F12%2F31%2Fcompetition-video%2F</url>
    <content type="text"><![CDATA[function doDecrypt(pwd, onError) { console.log("in doDecrypt"); var txt = document.getElementById("enc_content").innerHTML; var plantext; try { var bytes = CryptoJS.AES.decrypt(txt, pwd); plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) {onError(err);} return; } document.getElementById("enc_content").innerHTML = plaintext; document.getElementById("enc_content").style.display = "block"; document.getElementById("enc_passwd").style.display = "none"; } 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 请输入密码： var onError = function(error) { $("#enc_error")[0].innerHTML = "密码错误，请重新输入!"; }; function decrypt() { var passwd = $("#enc_passwd input")[0].value; doDecrypt(passwd, onError); }]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式(三)之工厂模式]]></title>
    <url>%2F2017%2F12%2F26%2Fdesign-pattern-factory%2F</url>
    <content type="text"><![CDATA[前言工厂模式是Java中最常用的设计模式之一。这种类型的模式属于创建型模式，它提供了一种创建对象的最佳方式，即创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 一、简单工厂模式定义简单工厂模式又叫静态工厂方法模式，是由一个工厂对象决定创建出哪一种产品类的实例。 结构图 Shape：接口，简单工厂模式创建的所有对象都是它的子类，它负责描述所有实例所共有的公共接口； Square、Circle、Rectangle：实现类，是简单工厂模式的创建目标； ShapeFactory：根据需要，工厂创建具体对象 FactoryPatternDemo：客户端，发出请求，通知ShapeFactory。 简单实现这里以上面的创建各种图形为例 创建图形接口这里创建一个图形的接口，它有一个绘制图形的方法123public interface Shape&#123; void draw();&#125; 创建具体的图形类这里创建各个具体的图形，它们都实现接口Shape，并实现其方法draw() 正方形(Square)123456public class Square implements Shape&#123; @Override public void draw()&#123; System.out.println(&quot;画正方形&quot;); &#125;&#125; 圆(Circle)123456public class Circle implements Shape&#123; @Override public void draw()&#123; System.out.println(&quot;画圆&quot;); &#125;&#125; 长方形(Rectangle)123456public class Rectangle implements Shape&#123; @Override public void draw()&#123; System.out.println(&quot;画长方形&quot;); &#125;&#125; 创建工厂接下来创建一个工厂ShapeFactory，他提供一个静态方法createShape用来绘制图形。只要你传入你想绘制的图形，它就会生成相应图形的实例。 1234567891011121314151617181920public class ShapeFactory&#123; public static Shape createShape(String type)&#123; Shape shape = null; switch(type)&#123; case &quot;Square&quot;:&#123; shape = new Square(); &#125; break; case &quot;Circle&quot;:&#123; shape = new Circle(); &#125; break; case &quot;Rectangle&quot;:&#123; shape = new Rectangle(); &#125; break; &#125; return shape; &#125;&#125; 客户端接着客户端调用工厂，传入你想绘制的图形，调用绘制图形的方法，就可绘制出你想要的图形。123456789101112public class FactoryPatternDemo&#123; public static void main(String args)&#123; Shape square = ShapeFactory.createShape(&quot;Square&quot;); square.draw(); Shape circle = ShapeFactory.createShape(&quot;Circle&quot;); circle.draw(); Shape rectangle = ShapeFactory.createShape(&quot;Rectangle&quot;); rectangle.draw(); &#125;&#125; 结果为：123画正方形画圆画长方形 使用场景 我们明确地计划不同条件下创建不同实例时； 客户只知道传入工厂类的参数对于如何创建对象(逻辑)不关心。 优缺点优点： 一个调用者像创建一个具体的对象，只要知道其名称就可以了； 扩展性高，如果想增加一个具体的产品，只要扩展一个工厂类就行了，同时屏蔽了产品的具体实现。 缺点： 如果增加新类型，使得系统中类的个数也会成倍增加，增加了系统的复杂性，同时也需要修改工厂，违背了开放封闭原则。因此下面的工厂模式将对其进一步优化。 二、工厂模式定义定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 注：工厂模式与简单工厂模式很相似，工厂模式中使用反射机制，弥补简单工厂模式中每次增加一个产品时，都需要增加一个对象实现工厂的缺点。即就是每增加一个类型，都需要修改工厂。 结构图工厂模式的结构图跟简单工厂模式的结构图差不多，唯一不同的就是ShapeFactory中实现的逻辑不一样罢了。 具体实现这里图形接口、各个具体的实现类跟上面的一样，因此我们只看ShapeFactory的实现方式： 创建工厂创建一个工厂ShapeFactory，它还是提供一个静态方法createShape用来绘制图形，但是传入的参数和实现逻辑与简单工厂模式略有不同： 1234567891011public class ShapeFactory&#123; public static &lt;T extends Shape&gt; T createShape(Class&lt;T&gt; clz)&#123; Shape shape = null; try&#123; shape = (Shape)Class.forName(clz.getName()).newInstance(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return (T)shape; &#125;&#125; 客户端123456789101112public class FactoryPatternDemo&#123; public static void main(String args)&#123; Square square = ShapeFactory.createShape(Square.class); square.draw(); Circle circle = ShapeFactory.createShape(Circle.class); circle.draw(); Rectangle rect = ShapeFactory.createShape(Rectangle.class); rect.draw(); &#125;&#125; 结果为：123画正方形画圆画长方形 优点同简单工厂模式相比较，可以看出，如果需要增加一个类型，先创建一个实现工厂接口的子类，然后在客户端调用即可，而不用再去修改工厂的内部逻辑。 总结从简单工厂模式中我们可以知道，工厂类中包含了必要的逻辑判断，根据不同的条件来动态实例化相关的类，对客户端来说，如果我们要增加一个产品，那我们就需要在工厂类中添加一个case分支条件，显然这违背了开放封闭原则，即对修改也开放了。而工厂模式就很好地解决了这个问题。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String之间的那点儿事]]></title>
    <url>%2F2017%2F12%2F24%2Fstring-detail-introduce%2F</url>
    <content type="text"><![CDATA[前言之前了解了String、StringBuilder和StringBuffer之间简单的区别，比如String是不可变的，StringBuilder是可变的，StringBuffer是线程安全的等，但对于它们为什么有这些特性却完全蒙蔽，知其然不知其所以然，因此下面将结合最近掌握的，对它们进行详细总结。 三者关系为了更好的理解这三者的关系，下面是它们的关系图： 从图中可以看出它们都是从CharSequence (是一个接口，表示char值的一个可读序列，此接口对许多不同种类的char序列提供统一的读写访问)扩展而来，同时String、StringBuilder和StringBuffer的本质都是通过字符数组实现的。 String详解常见创建方式 方式一：使用关键字new，如：String s1 = new String(“Hello World”); 方式二：直接定义，如：String s2 = “Hello World”; 当然通过构造函数创建一个String还有很多其他方式，这里就以参数为String的为例 下面通过简单的内存分析图，说明这两种方式的区别：因此从上面可以看出使用方式一，内存为其分配了两个对象，至于常量池中”Hello World”为什么是一个对象，这就要更深层次的分析了，这里就不做过多的解释；而方式二只创建了一个对象。 因此这里就得出了平时的结论：&emsp;&emsp;1、当需要创建String字符串时，推荐使用方式二的形式，因为使用方式一增大堆内存的消耗；&emsp;&emsp;2、它们之间的“==”关系：1234567public class TestString&#123; public static void main(String[] args)&#123; String str1 = new String("Hello World"); String str2 = "Hello World"; System.out.println(str1 == str2); &#125;&#125; &emsp;&emsp;当然结果为：false，因为str1、str2不是引用的同一个对象。&emsp;&emsp;3、从图中可以看出String的内部通过char[] value进行管理的，因此String的本质是字符数组。 源码解析类定义12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; String被final修饰，说明该类不能被继承； 实现Serializable，说明可以序列化和反序列化； 实现Comparable，说明可以进行自定义的字符串比较； 实现CharSequence，说明利用CharSequence可以实现读写方式。 成员变量源码中可以看见这样一个成员变量：12//存储字符串中元素的字符数组private final char value[]; 该成员变量是一个字符数组表明，String的本质就是一个字符数组，通过这个字符数组来存储字符内容； 该字符数组被final修饰，而且value是引用变量，因此可以知道一旦被初始化，即指向内存中一个数组，就不能再指向别的数组了； 看到这里我们就可以得出结论：String是不可变的！注意：String不可变是指其内容不能被修改，但是其引用还是可以指向其他内容。 &emsp;&emsp;比如：1234String s3 = "abc";String s4 = "def";s3 = s4;System.out.println(s3); &emsp;&emsp;因此输出结果为：def &emsp;&emsp;这里拿图说话 ☟：&emsp;&emsp;因此从图可知，s3的原来所引用的对象内容确实没有改变，改变的仅仅是s3引用的对象。 &emsp;&emsp;⊙(・◇・)？ 思考：s3所引用的对象内容到底可不可改变&emsp;&emsp;&emsp;&emsp;我们都知道对象引用，引用的是对象的地址，它根本就不知道对象的实际内容，因此如果String类中如果提供一个可以修改value字符串数组内容的方法，那么String就变成可修改的了，因此实际上String没有这么一个方法。实际上也不应该提供这么一个方法，否则String类就没有意义了。 常用方法介绍上面详细介绍了String类的特性，下面对其几个常用方法进行简要分析，以此对String类的相关特性进一步了解： 1、构造方法：&emsp;&emsp;(1)、无参构造函数：会创建一个空的字符序列，因为字符串是不可变的，所以没必要使用。123public String() &#123; this.value = new char[0];&#125; &emsp;&emsp;(2)、String为参数的构造函数：这个构造方法会产生两个字符串对象，用来初始化一个和输入参数具有相同字符序列的字符串对象，换句话说，新建的这个字符串对象是传入的字符串参数对象的一份副本，除非是明确地需要使用字符串复制功能，否则由于字符串常量值是不可变的，这个构造函数是没有必要使用。1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; &emsp;&emsp;(3)、将传入的字符数组复制到一个新的字符数组，并将当前对象的value(即this.value)指向它。12345678910public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125;public String(char value[], int offset, int count) &#123; . . . this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; &emsp;&emsp;(4)、使用字节数组创建字符串，同时还可以使用指定的解码方式进行解码。 123456public String(byte bytes[])public String(byte bytes[], int offset, int length) // 从offset开始，长度为length 并以默认的 ISO-8859-1 编码转换成字符串public String(byte bytes[], Charset charset)public String(byte bytes[], String charsetName)public String(byte bytes[], int offset, int length, Charset charset)public String(byte bytes[], int offset, int length, String charsetName) 2、常用方法：&emsp;&emsp;(1)、字符串截取，创建了一个新数组，因此牺牲了一定的空间性能。1234567891011121314public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);&#125; &emsp;&emsp;(2)、比较两个字符串，可以看出是比较的一个一个字符内容，因此两个相同字符串内容的String对象比较，都是true123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i])//对两个字符串中的字符一个一个比较 return false; i++; &#125; return true; &#125; &#125; return false;&#125; String中还有很多其他方法，具体的自己可以去看看源码，基本上都是字符数组的操作~~~ 扩展：到底创建了几个对象？概念常量池：指的是在编译期被确定，并保存在以编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的==常量==，也包括==字符串常量==。 情形一12String a = "abc";String b = "abc"; 上面总共创建了一个对象，由于执行到第一行时常量池中并不存在”abc”，故需要创建一个对象，执行到第二行时，由于常量池中存在”abc”，故直接共享常量池中的内容，因此不会创建对象。 情形二1234String test = "abcdefxyz";String s5 = "abc" + "def";String s6 = s5 + "xyz";System.out.println(test == s6);//false 上面两句代码各创建了几个对象：&emsp;&emsp;(1)、首先对于String s5 = “abc” + “def”; 一般我们会认为创建了两个对象，即”abc”和”def”，其实不然，由于常量的值在编译时执行“+”就被确定了，因此变量s5在编译时就可以确定为”abcdef”，因此实际上只创建了一个对象，其实这里就是Java中String的一种优化。&emsp;&emsp;(2)、对于String s6 = s5 + “xyz”; 由于s5是一个变量，在编译时它的值并不确定，故并不会实现编译优化，因此就会产生两个对象，即”xyz”和”abcdefxyz”。12345String test = "aaabbb";final String s7 = "aaa";final String s8 = "bbb";String s9 = s7 + s8;System.out.println(test == s9);//true &emsp;&emsp;(3)、对于上面的String s9 = s7 + s8; 并不产生对象，因为s7、s8均为常量，所以编译时就能确定，编译时就会将常量替换，等同于是s9 = “aaa”+”bbb”，因此不产生新对象。 结论： 使用“+”连接的两个字符串本身就是字面常量字符串时，如果池中存在这样连接后的字符串，则是不会重新创建对象，而是直接引用池中的字符串对象； 如果“+”连接的两字符串中只要有一个不是字面常量串（即定义过的），是会产生新的字符串对象。 情形三1234567891011//案例一String s7 = new String("abc");for(int i = 0;i &lt; 100;i++)&#123; s7 = s7 + i;&#125;//案例二String s8 = "def";for(int i =0;i &lt; 100;i++)&#123; s8 = s8 + i;&#125; &emsp;&emsp;因此从前面我们可以知道案例一情况下，将会产生102个对象；案例二情况下，将会产生101个对象。因此当我们的程序中需要大量的拼接字符串时，应该使用效率更高的StringBuilder。 优点从上面可以看出虽然String不可变，但是总有其好处： 由于它的不可变特性，当我们传参数时，使用不可变类不需要去考虑谁可能会修改其内部的值，因此相对较安全； 由于常量池的作用，对个引用变量可以引用同一个字符串实例，避免频繁创建实例的开销。 结语由于文章篇幅较长，因此将分两部分介绍，传送☞ ++深度解析StringBuilder和StringBuffer++]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式(二)之单例模式]]></title>
    <url>%2F2017%2F12%2F15%2Fdesign-pattern-singleton%2F</url>
    <content type="text"><![CDATA[前言单例模式(Singleton Pattern)是Java中最简单的设计模式之一。这种模式设计到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，外部不需要实例化该类的对象。 结构图一般单例模式共有六种，单例模式根据实例化对象时机的不同主要分为两种： 饿汉式：该类型在单例类被加载时候，就实例化一个对象交给自己的引用； 懒汉式：当需要时才会去加载，并实例化该对象。 懒汉式(线程不安全)12345678910111213141516171819public class Singleton&#123; //声明一个私有化静态变量 private static Singleton instance; //构造器私有化，避免外部直接创建对象 private Singleton()&#123; &#125; //对外提供一个公共的静态方法访问该变量，如果该变量没有对象，则创建 public static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 说明： 该方式在用户第一次调用时初始化，实现了懒加载，但是在多线程环境下不能工作。 懒汉式(线程安全)1234567891011121314151617181920public class Singleton&#123; //声明一个私有化静态变量 private static Singleton instance; //构造器私有化，避免外部直接创建对象 private Singleton()&#123; &#125; //对外提供一个公共的静态方法访问该变量，如果该变量没有对象，则创建 //同时使用synchronized保证了线程的安全 public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 说明： 该方式具备懒加载，在多线程下能很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，因此该方法不常使用。 饿汉式123456789101112131415public class Singleton&#123; //声明私有静态变量，同时创建该对象，因此类加载时该对象就已经存在 private static Singleton instance = new Singleton(); //构造器私有化，避免外部直接创建对象 private Singleton()&#123; &#125; //对外提供公共的静态方法访问该对象 public static Singleton getInstance()&#123; return instance; &#125;&#125; 说明： 该方式在类加载时就完成了初始化，因此不具备懒加载，但获取对象的速度快，但是该方式基于类加载机制避免了多线程的同步问题，因此是线程安全的，没有加锁，执行效率会提高 双重校验方式12345678910111213141516171819202122public class Singleton&#123; //声明一个私有化静态变量 private volatile static Singleton instance= null; //构造器私有化，避免外部直接创建对象 private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(instance == null)&#123;//当存在该对象时，直接返回该对象，为了提高效率，避免互斥等待 synchronized (Singleton.class) &#123;//保证多线程的安全 if(instance == null)&#123;//确保一个类只有一个对象 instance = new Singleton(); &#125; return instance; &#125; &#125; return instance; &#125;&#125; 说明： 注意两个if条件的作用，第一个if是为了避免每次getInstance()都进行不必要的同步，第二个if是为了在instance为null的条件下，创建该类的实例。该方式采用双锁机制，安全且在多线程下能保持高性能，同时该方式也是在需要的时候才去加载，效率高，有很好的懒加载效果。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。同时程序中使用volatile会或多或少的影响性能，但考虑到程序的正确性，牺牲这点性能还是值得的。 静态内部类方式1234567891011121314151617public class Singleton&#123; //定义一个静态内部类 private static class SingleHolder&#123; private static Singleton instance = new Singleton(); &#125; //私有化构造函数 private Singleton()&#123; &#125; //在需要时才去加载 public Singleton getInstance()&#123; return SingleHolder.instance; &#125;&#125; 说明： 当Singleton类加载时，SingleHolder并不会加载，只有在第一次调用getInstance()时，SingleHolder才会加载，因此保证了线程安全和Singleton类的唯一性，同时具备很好的懒加载。该种方式跟双重校验能达到相同效果，但是该方式只适用于静态域的情况，双重校验方式可在实例域需要延迟初始化时使用。 枚举类型方式1234567public enum Singleton&#123; INSTANCE; public void doSomeThing() &#123; &#125; &#125; 说明： 默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，因此不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。但是该种方式，用的比较少，可读性不高。 扩展 上面六种方式，除了枚举类型单例，其余的方式在反序列化情况下会重新创建对象，即将一个单例实例对象从磁盘或者网络写回来时，为了避免这种情况，反序列化操作提供了readResolve方法，这个方法可以让开发人员控制对象的反序列化，因此在上述的几个方法示例中如果要杜绝单例对象被反序列化时重新生成对象，就必须加入如下方法： 123private Object readResolve() thows ObjectStreamException&#123; return instance;&#125; 上面说到序列化时，会产生多个实例，同时在分布式系统、多个类加载器的情况下都会产生多个单例实例。同时使用反射方式，也会得到新的单例： 1234Class c = Class.forName(Singleton.class.getName()); Constructor ct = c.getDeclaredConstructor(); ct.setAccessible(true); Singleton singleton = (Singleton)ct.newInstance(); 这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。 总结特点： 一个单例类只能有一个实例； 单例类必须自己创建自己的唯一实例； 单例类必须给所有其他对象提供这一实例。 优点： 在内存中只有一个对象，节省内存空间； 避免频繁的创建销毁对象，可以提高性能； 避免对共享资源的多重占用； 可以全局访问。 注意： 只能使用单例类提供的getInstance()得到单例对象，不要使用反射，否则将会实例化一个新对象； 不要做断开单例类对象与类中静态引用的危险操作； 多线程使用单例使用共享资源时，注意线程安全问题； 在反序列化时，重写readResolve()方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式(一)之概述]]></title>
    <url>%2F2017%2F12%2F15%2Fdesign-pattern-summary%2F</url>
    <content type="text"><![CDATA[前言设计模式是一套被反复使用的、多数人知晓的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编制真正工程化，它是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 设计模式类型创建型模式这些设计模式提供了一种在创建对象的同时隐藏其创建逻辑的方式，而不是直接使用new运算符直接实例化对应的对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。具体有以下几种： 工厂模式 抽象工厂模式 单例模式 建造者模式 原型模式 结构型模式该类设计模式关注类和对象的组合，是一种使用继承和定义接口以获取新功能的方式。具体有以下几种：： 适配器模式 桥接模式 过滤器模式 组合模式 装饰器模式 外观模式 享元模式 代理模式 行为型模式该类设计模式特别关注对象之间的通信。具体有以下几种： 责任链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 空对象模式 策略模式 模板模式 访问者模式 设计六大原则1、单一职责原则含义：&emsp;&emsp;就一个类而言，引起他的变化应该仅有一个，即一个类只负责一项职责。 解读：&emsp;&emsp;这句话的含义就是不要让一个类承担过多的职责，如果一个类承担的职责过多，就等于将这些职责耦合在一起，一个职责的变化可能会引起这个类中其他职责的变化，甚至会削弱或抑制这个类完成其他职责的能力，以致当这个类中的某个职责发生变化时，设计会遭到破坏。&emsp;&emsp;就像之前做Android的时候，在一个Activity中既要关注界面的变化、又要对数据进行处理，以致于如果这个Activity要实现的功能比较复杂的话，那么这个Activity类中的代码是比较臃肿的，导致后期维护时，对于他人来说是比较蛋疼的，修改了一个地方可能会引起其他地方相应作出修改，这样就会导致引起这个Activity变化原因过多。因此也就背离了单一职责原则的含义。 说明：&emsp;&emsp;1、单一职责原则降低了类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多；&emsp;&emsp;2、它提高类的可读性，提高系统的可维护性；&emsp;&emsp;3、让变更引起的风险降低，变更是必然的，如果单一职责原则遵守好，当修改一个功能时，可以显著降低对其他功能的影响。 2、里氏替换原则含义：&emsp;&emsp;所有使用基类的地方必须能透明地使用其子类的对象。 解读：&emsp;&emsp;在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，即使用基类的地方一定能够使用其子类。反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。&emsp;&emsp;里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。&emsp;&emsp;例如在一个邮件系统中，用户分为普通用户可VIP用户，但是这两种类型都具有发邮件的功能，因此相应的类图为：但是我们在实现在，无论是普通用户还是VIP用户，发邮件的过程都是相同的，因此两个send方法中的代码将会重复，如果以后还会增加其他类型的用户呢？那么这个系统的代码将会很冗余。因此通过里氏替换原则，可以对其进行如下修改:这里增加了一个抽象类，作为所有类型的基类，发送类EmailSender类针对抽象客户类Customer编程，因此我们用基类类型来对对象进行定义，当运行时再确定其子类类型，从而实现用子类对象来代替基类对象。同时如果还需要增加其他类型的话，只需要继承Customer类就行。 说明：&emsp;&emsp;使用里氏替换原则需要注意以下几点：&emsp;&emsp;1、子类的所有非私有方法应该在基类中声明，或子类必须实现父类中声明的方法(子类可以扩展基类的功能，但不能改变基类原有的功能)。即为了保证系统的扩展性，在程序中通常使用基类来进行定义，如果一个方法只存在子类中，在子类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。&emsp;&emsp;2、在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。这里也体现了里氏代换原则是开闭原则的具体实现手段之一。&emsp;&emsp;3、Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。 3、依赖倒置原则含义：&emsp;&emsp;高层模块不应该依赖底层模块，两者都应该依赖其抽象。即：抽象不应该依赖细节，细节应该依赖抽象。 解读：&emsp;&emsp;在Java中，抽象就是指接口或抽象类，两者是不能直接被实例化的，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成，而细节就是实现类，实现接口或继承抽象类而产生的就是细节。而高层模块就是调用者，底层模块就是具体实现类。&emsp;&emsp;依赖倒置原则在Java中的表现就是：模块间通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合，那么当修改时，就会同时修改依赖者代码，这样限制了可扩展性。&emsp;&emsp;例如下面这个例子：一个学生应该具有学习多门课程的能力。比如他喜欢学习语文。123456789101112131415161718public class StudyChinese&#123; public String ability()&#123; return "我能学习语文!"; &#125;&#125;public class Student&#123; public void study(StudyChinese chinese)&#123; System.out.println(chinese.ability()); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Student student = new Student(); student.study(new StudyChinese()); &#125;&#125; 此时可以看出该学生能够学语文，但是还应该能够学习数学、英语等，要实现这些那么我们应该将Student不断进行修改，显然这样操作的话，各个类之间的耦合度就太高了。因此我们可以引入一个接口：123interface IStudy&#123; public String ability();&#125; 这样该学生就不止会学语文了：12345678910111213141516171819202122232425public class StudyChinese impliments IStudy&#123; public String ability()&#123; return "我能学习语文!"; &#125;&#125;public class StudyMath impliments IStudy&#123; public String ability()&#123; return "我能学习数学!"; &#125;&#125;public class Student&#123; public void study(IStudy study)&#123; System.out.println(study.ability()); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Student student = new Student(); student.study(new StudyChinese()); student.study(new StudyMath()); &#125;&#125; 因此现在只需要修改Client，就能扩展该学生的知识，学习相应的课程。从而就不用再去修改Student类了。 说明：&emsp;&emsp;1、底层模块尽量都要有接口或抽象类；&emsp;&emsp;2、形参类型尽量为接口或抽象类类型，即遵循里氏替换原则。&emsp;&emsp;3、传递依赖关系有三种方式，分别为：接口传递、构造方法传递、setter方法传递，以上的例子使用的是接口传递。&emsp;&emsp;4、通过上面的例子可以看出依赖倒置原则给并行开发带来了极大的便利，先前Student类和StudyChinese类耦合在一起，就是说Student类必须等StudyChinese类完成后才能编码；而优化后的程序可以看出St类与StudyChinese、StudyMath类没有任何直接关系，因此将提高开发效率。 4、接口隔离原则含义：&emsp;&emsp;客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 解读：&emsp;&emsp;建立接口时，应该建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。&emsp;&emsp;就如下面的例子：12345678910111213141516171819202122232425262728293031323334353637383940interface I&#123; public void method1(); public void method2(); public void method3(); public void method4();&#125;//对于类A只需要method1、m但因为实现接口I，因此也要实现不需要的method3、method4，即使这两个方法的方法体为空。public class A impliments I&#123; public void method1()&#123; System.out.println("实现方法一"); &#125; public void method2()&#123; System.out.println("实现方法二"); &#125; public void method3()&#123; &#125; public void method4()&#123; &#125;&#125;//类B与A相识，为了实现接口I也要实现不需要的method1、method2public class B impliments I&#123; public void method1()&#123; &#125; public void method2()&#123; &#125; public void method3()&#123; System.out.println("实现方法三"); &#125; public void method4()&#123; System.out.println("实现方法四"); &#125;&#125; 因此从上面可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用，实现类中都必须去实现这些方法。因此我们可以对接口进行拆分：1234567891011121314151617181920212223242526272829interface I1&#123; public void method1(); public void method2();&#125;interface I2&#123; public void method3(); public void method4();&#125;public class A impliments I1&#123; public void method1()&#123; System.out.println("实现方法一"); &#125; public void method2()&#123; System.out.println("实现方法二"); &#125;&#125;public class B impliments I2&#123; public void method3()&#123; System.out.println("实现方法三"); &#125; public void method4()&#123; System.out.println("实现方法四"); &#125;&#125; 因此在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 说明：&emsp;&emsp;1、接口应该尽量小，但是要有限度，因为接口过小的话，就会造成接口数量过多，使设计复杂化。因此要掌握好这个“度”应该在平时对相应问题进行仔细思考。&emsp;&emsp;2、要建立最小的依赖关系，应该为依赖接口的类定制服务，即之暴露给调用的类它需要的方法，将不需要的方法隐藏起来。&emsp;&emsp;3、注意与单一职责原则相区别：&emsp;&emsp;&emsp;(1)、单一职责原则原注重的是职责，而接口隔离原则注重对接口依赖的隔离；&emsp;&emsp;&emsp;(2)、单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。 5、迪米特法则含义：&emsp;&emsp;一个软件实体应当尽可能少的与其他实体发生相互作用，又叫做最少知道原则。 解读：&emsp;&emsp;通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。&emsp;&emsp;迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。&emsp;&emsp;例如下面的例子：当ClassBase有动作时时，和它有关联的类ClassB、ClassC、ClassD等都将发生改变。因此从上面可以看见由于类之间的交互关系复杂，导致在该系统中增加新的对象时需要修改与之交互的其它类的源代码，系统扩展性较差，也不便于增加和删除新对象。&emsp;&emsp;下面将引入一个专门用于控制对象间交互的中介类(Agent)来降低各对象之间的耦合度。引入中间类之后，相关对象之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其它对象的调用。当需要增加或删除新的对象时，只需修改中间类即可，无须修改新增对象或已有对象的源代码。 说明：&emsp;&emsp;1、在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；&emsp;&emsp;2、在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；&emsp;&emsp;3、在类的设计上，只要有可能，一个类型应当设计成不变类；&emsp;&emsp;4、在对其他类的引用上，一个对象对其他对象的引用应当降到最低。&emsp;&emsp;5、迪米特法则的另外一层含义是：只与直接的朋友通信。直接朋友指：&emsp;&emsp; (1)、当前对象本身(this);&emsp;&emsp; (2)、以参量形式传入到当前对象方法中的对象;&emsp;&emsp; (3)、当前对象的实例变量直接引用的对象;&emsp;&emsp; (4)、当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友;&emsp;&emsp; (5)、当前对象所创建的对象。&emsp;&emsp; 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”。 6、开放封闭原则含义：&emsp;&emsp;多扩展开放、对修改关闭，即类、函数等等应该能够扩展，而不是去修改。 解读：&emsp;&emsp;从上面的含义我们知道该原则有两方面的意思，一个就是对于扩展是开放的，另一个就是对于修改是封闭的。就是说当程序需要进行扩展的时候，不能去修改原有的代码，实现一个热插拔的效果。因为在实际开发中需求的改变在所难免，但是需求一变就把所涉及的类重新改一遍这个显然很头疼，因此我们在设计程序时，要针对需求尽量保证代码的相对稳定。简言之，就是为了使程序的扩展性好，易于维护和升级。&emsp;&emsp;其实从上面的叙述来说，开放封闭有点模糊，尽管知道要扩展开放、对修改关闭，但是如何才能做到呢？其实我们经过前面五大原则可以发现，要实现开放封闭原则，无非就是用抽象构建框架，用实现扩展细节，因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。 说明：&emsp;&emsp; 1、里氏替换原则开放封闭原则的实现提供保证；&emsp;&emsp; 2、封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态一般将其封装为一个抽象，但是拒绝滥用抽象，只将经常变化的部分进行抽象。 总结对于上面的六大原则可概括为： 单一职责原则: 实现类要职责单一; 里氏替换原则: 不要破坏继承体系; 依赖倒置原则: 使用面向接口编程; 接口隔离原则: 设计接口精简单一; 迪米特法则:&emsp; 类与类要降低耦合。 对于这六大原则的使用，我们应该尽量合理地遵守，也不用刻意去遵守，否则将会遵守过渡。对于具体如何使用，就要靠平时的学习积累，以及依照个人经验来定，当然经验的好坏，将决定整个设计的质量。 结语提高自己的方法有很多，将自己学过的以这种方式记录下来，希望自己有所收获，同时希望能够帮助需要帮助的人~~~]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Github搭建属于自己的博客By Hexo]]></title>
    <url>%2F2017%2F12%2F13%2F%E4%BD%BF%E7%94%A8Github%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2By-Hexo%2F</url>
    <content type="text"><![CDATA[前言其实平时自己写的文章并不多，偶尔看到一些东西会做点笔记，但是每次写的东西都会到处放，不好找，所以才想着自己搭建一个人博客网站。作为自己博客的开篇之作，仅仅想用这种方式来记录自己搭建博客的过程，希望能给需要的朋友带来帮助。现在大家用hexo比较多，也比较方便，并且能使用的主题也很多，因此下面将讲述使用Github和Hexo来搭建属于自己的博客！ 环境准备安装Git初次安装可以按照下面步骤操作，如果已安装可以忽略 下载 Git 然后执行安装文件，如果没有特殊需求的话，一路next就行。 运行cmd打开命令符提示窗口，输入下面的命令，如果出现以下界面，代表Git安装成功。 1git version 安装Node.js Hexo是基于Node.js环境的静态博客，需要使用Node.js的npm命令，因此下载 Node.js (注意：LTS为长期支持版，Current为当前最新版) 并执行安装文件，一路next。 运行cmd打开命令符提示窗口，输入下面的命令，如果出现以下界面，代表Node.js安装成功。 12node -vnpm -v 安装Hexo 首先在一个空的文件夹下（如 D:\hexo），输入下面的命令(在 D:\hexo 内点击鼠标右键，选择 Git Bash Here)，当出现以下类似界面时，代表Hexo安装成功 12npm install hexo-cli -ghexo -v 输入以下命令，初始化完成后将在当前文件夹下看见如下所示的文件 12npm install hexo --savehexo init 12345678910├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json #项目所需模块项目的配置信息 初始化hexo后，接着输入下面命令，同样也是做初始化 1npm install 如果上面的操作都没有问题的话，接下来输入如下命令，这两步操作就是加载hexo对应的html、css、js等文件，并且开启本地服务器，操作完成后在浏览器输入http://localhost:4000/ 就可以看见如下界面，说明本地hexo默认模板配置成功。 12hexo ghexo s Github创建仓库经过上面的操作，我们已经在本地搭建好了相关环境，并且已经看见了我们的默认博客界面，那么如何通过外部链接访问我们的博客呢？下面将一一叙述： 如果你还没有 Github 账号，请先创建一个，然后用自己创建的账号进行登录。并按照如下步骤操作： 添加SSH，在本机任何位置右击，选择Git Gui Here，弹出的界面，点击Help-&gt;Show SSH Key，复制你的SSH。(添加SSH的目的可以避免以后每次部署时都需要输入用户名和密码) 回到刚刚创建的仓库界面，依次按照下面步骤操作： 当添加完毕后，如果你是初次安装的话，需要进行在git中配置GitHub信息，如下所示(name和email均与Github相对应)： 当配置完成后，可以进行如下进行验证1ssh -T git@github.com 到这里环境搭建部分就结束了，下面我们将自己的本地博客部署到Github上面。 Hexo部署修改配置文件 在刚才初始化生成的文件中有一个_config.yml文件，用编辑器打开，定位到下面位置所示，进行相应的修改。 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 常见Hexo命令在正式部署之前，先简单了解下Hexo常用的命令，如下：12345678hexo help #查看帮助hexo init #初始化一个目录hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成网页，可以在 public目录查看整个网站的文件hexo server #本地预览，'Ctrl+C'关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 相应的简写形式为：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 上传Github 首先执行如下命令，目的是安装相应的插件 1npm install hexo-deployer-git --save 同时在该目录下(比如 D:\hexo)，打开gitbash，输入如下命令： 123hexo cleanhexo generatehexo deploy 注意：首次deploy(部署)的时候，可能会叫你输入username和password(与Github上的信息相对应就行)。 当看到如下信息时，就代表部署成功，同时在Github上点击该项目对应的setting，并且定位到Github Pages，会看到如下提示：Your site is published at http://yourname.github.io 1[info] Deploy done: git 最后再浏览器中输入http://yourname.github.io 就能访问你的博客了。 至此自己的博客就搭建完成了，但是目前访问的是Hexo的一个默认页面。下面将叙述如何DIY自己的博客，以及如何导入模板主题。 主题配置安装主题由于Hexo提供的主题较多，大家可以去github搜自己喜欢的主题，这里我使用的是Hexo提供的hexo-theme-next主题，个人觉得这个主题比较简洁，但是不同主题安装的方法都大致相同，只不过相关的配置有些差异而已。因此下面将以next主题为例一步一步叙述。 选中自己比较喜欢的主题后，获取对应的链接， 然后在我们本地hexo目录下打开gitbash，执行下面命令(注意这里是以next主题为例)，目的是将其主题对应的工程clone下来。 1git clone https://github.com/iissnan/hexo-theme-next themes/next 注意：到目前为止我们已经将自己喜欢的主题clone下来了，因此在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。所以我们常将将前者称为站点配置文件， 后者称为主题配置文件。 然后打开站点配置文件，找到theme字段，并将其值改为next 1theme: next 打开本地服务器进行验证，当看见如下界面是，就说明Next主题安装成功。 1hexo s 如果想更改其他内容，均可以在站点配置文件和主题配置文件中进行相应的配置。以下为站点配置文件的详细内容(对照着注基本上没有问题)： 需要注意的是： 配置文件的冒号 “:” 后面有一个空格; 如果修改了配置文件存在中文乱码问题，就将配置文件另存为utf-8的格式。 站点配置文件详细说明：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Hexo Configuration# Docs: http://hexo.io/docs/configuration.html# Source: https://github.com/hexojs/hexo/# Site #站点信息title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言# URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy: type: git repo: 刚刚github创库地址.git branch: master 主题详细配置对于主题配置文件多用于个性化设置，不同的主题略有差异，因此大家可以参考各个主题的官方说明进行修改。 绑定个人域名如果你有自己的域名，也可以进行绑定，到时候直接使用你的域名网址打开即可，具体操作流程如下： 购买域名，你可以到阿里云或者其他网站购买一个域名 在DNS中对你购买的域名进行解析，其中记录值为你yourname.github.io对应的IP地址，在cmd中可以进行查看(使用ping命令)，查看方法如下。 在Github上点击该项目对应的setting，并且定位到Github Pages，在如图所示位置填上自己的域名，点击SAVE，同时可看见提示：Your site is published at “你的域名” 在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是limynl.site，只能添加一个哦。 将本地工程部署一下，用你购买的域名打开，就可以看到你的博客了~~ 结语 对于使用Github搭建属于自己的博客，大致过程就是这样。但是文中也许有一些小错误，欢迎大佬们指出~~，当然如果大家从我的博客有所收获，那最好不过。 最后想到了一句话，共勉：大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
