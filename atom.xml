<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Limynl</title>
  
  <subtitle>一枚不断努力的小白</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://limynl.site/"/>
  <updated>2018-02-26T06:18:18.366Z</updated>
  <id>http://limynl.site/</id>
  
  <author>
    <name>Limynl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>无题</title>
    <link href="http://limynl.site/2017/12/31/competition-video/"/>
    <id>http://limynl.site/2017/12/31/competition-video/</id>
    <published>2017-12-31T04:35:02.000Z</published>
    <updated>2018-02-26T06:18:18.366Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><span>    </span><br><a id="more"></a></p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"http://p1syj1ah9.bkt.clouddn.com/limynl/site/%E8%80%81%E9%A9%AC%E8%AF%86%E5%9B%BE_%E6%BC%94%E7%A4%BA%E8%A7%86%E9%A2%91.mp4","pic":"http://139.199.23.142:8080/TestShowMessage1/spring.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/1.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/2.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/3.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/3.1.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/4.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/5.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/6.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/7.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/8.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/9.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/10.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/11.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/12.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/13.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/14.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/15.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/16.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/17.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/18.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/19.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/20.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/21.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/22.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/23.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/24.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/25.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/26.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/27.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/28.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/29.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/30.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/31.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/32.png" width="200"></td></tr><tr><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/33.png" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/34.PNG" width="200"></td><td><img src="http://p1syj1ah9.bkt.clouddn.com/app/35.PNG" width="200"></td></tr></tbody></table><p><img src="http://p1syj1ah9.bkt.clouddn.com/app/book_background_4.jpg" width="200"></p><!--  <div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"http://p1syj1ah9.bkt.clouddn.com/limynl/site/%E8%80%81%E9%A9%AC%E8%AF%86%E5%9B%BE_%E6%BC%94%E7%A4%BA%E8%A7%86%E9%A2%91.mp4","pic":"home.ustc.edu.cn/~mmmwhy/GEM.jpg"},"danmaku":{"id":"9E2E3368B56CDBB4","api":"http://dplayer.daoapp.io","token":"tokendemo","addition":["https://dplayer.daoapp.io/bilibili?aid=4157142"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> –&gt;<!-- <div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px; width:233px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","loop":true,"video":{"url":"http://devtest.qiniudn.com/若能绽放光芒.mp4","pic":"http://devtest.qiniudn.com/若能绽放光芒.png"},"danmaku":{"id":"2622668","api":"http://dplayer.donot.help/dplayerpy","addition":["https://dplayer.daoapp.io/bilibili?aid=4157142"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"autoplay":true,"video":{"url":"some.mp4"},"danmaku":{"id":"someid","api":"https://api.prprpr.me/dplayer/","addition":["/some.json"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);player.on("loadstart",function(){console.log("loadstart")})})()</script><p> –&gt;</p>-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://limynl.site/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式(三)之工厂模式</title>
    <link href="http://limynl.site/2017/12/26/design-pattern-factory/"/>
    <id>http://limynl.site/2017/12/26/design-pattern-factory/</id>
    <published>2017-12-26T01:20:46.000Z</published>
    <updated>2017-12-26T08:19:47.460Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="http://p0w1t27p0.bkt.clouddn.com/limynl/site/factory_pattern_background.jpeg?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工厂模式是Java中最常用的设计模式之一。这种类型的模式属于创建型模式，它提供了一种创建对象的最佳方式，即创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<br><a id="more"></a></p><h2 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单工厂模式又叫静态工厂方法模式，是由一个工厂对象决定创建出哪一种产品类的实例。</p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://p0w1t27p0.bkt.clouddn.com/limynl/simple_factory_pattern.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p><ul><li>Shape：接口，简单工厂模式创建的所有对象都是它的子类，它负责描述所有实例所共有的公共接口；</li><li>Square、Circle、Rectangle：实现类，是简单工厂模式的创建目标；</li><li>ShapeFactory：根据需要，工厂创建具体对象</li><li>FactoryPatternDemo：客户端，发出请求，通知ShapeFactory。</li></ul><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>这里以上面的创建各种图形为例</p><h4 id="创建图形接口"><a href="#创建图形接口" class="headerlink" title="创建图形接口"></a>创建图形接口</h4><p>这里创建一个图形的接口，它有一个绘制图形的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape&#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="创建具体的图形类"><a href="#创建具体的图形类" class="headerlink" title="创建具体的图形类"></a>创建具体的图形类</h4><p>这里创建各个具体的图形，它们都实现接口Shape，并实现其方法draw()</p><p><strong>正方形(Square)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        System.out.println(&quot;画正方形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>圆(Circle)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        System.out.println(&quot;画圆&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>长方形(Rectangle)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        System.out.println(&quot;画长方形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="创建工厂"><a href="#创建工厂" class="headerlink" title="创建工厂"></a>创建工厂</h4><p>接下来创建一个工厂ShapeFactory，他提供一个静态方法createShape用来绘制图形。只要你传入你想绘制的图形，它就会生成相应图形的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory&#123;</span><br><span class="line">   public static Shape createShape(String type)&#123;</span><br><span class="line">       Shape shape = null;</span><br><span class="line">       switch(type)&#123;</span><br><span class="line">           case &quot;Square&quot;:&#123;</span><br><span class="line">               shape = new Square();</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">           case &quot;Circle&quot;:&#123;</span><br><span class="line">               shape = new Circle();</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">           case &quot;Rectangle&quot;:&#123;</span><br><span class="line">               shape = new Rectangle();</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">       return shape;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>接着客户端调用工厂，传入你想绘制的图形，调用绘制图形的方法，就可绘制出你想要的图形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryPatternDemo&#123;</span><br><span class="line">    public static void main(String args)&#123;</span><br><span class="line">        Shape square = ShapeFactory.createShape(&quot;Square&quot;);</span><br><span class="line">        square.draw();</span><br><span class="line">        </span><br><span class="line">        Shape circle = ShapeFactory.createShape(&quot;Circle&quot;);</span><br><span class="line">        circle.draw();</span><br><span class="line">        </span><br><span class="line">        Shape rectangle = ShapeFactory.createShape(&quot;Rectangle&quot;);</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">画正方形</span><br><span class="line">画圆</span><br><span class="line">画长方形</span><br></pre></td></tr></table></figure></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>我们明确地计划不同条件下创建不同实例时；</li><li>客户只知道传入工厂类的参数对于如何创建对象(逻辑)不关心。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>一个调用者像创建一个具体的对象，只要知道其名称就可以了；</li><li>扩展性高，如果想增加一个具体的产品，只要扩展一个工厂类就行了，同时屏蔽了产品的具体实现。</li></ul><p><strong>缺点：</strong></p><ul><li>如果增加新类型，使得系统中类的个数也会成倍增加，增加了系统的复杂性，同时也需要修改工厂，违背了开放封闭原则。因此下面的工厂模式将对其进一步优化。</li></ul><h2 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。    </p><blockquote><p>注：工厂模式与简单工厂模式很相似，工厂模式中使用反射机制，弥补简单工厂模式中每次增加一个产品时，都需要增加一个对象实现工厂的缺点。即就是每增加一个类型，都需要修改工厂。</p></blockquote><h3 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h3><p>工厂模式的结构图跟简单工厂模式的结构图差不多，唯一不同的就是ShapeFactory中实现的逻辑不一样罢了。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>这里图形接口、各个具体的实现类跟上面的一样，因此我们只看ShapeFactory的实现方式：</p><h4 id="创建工厂-1"><a href="#创建工厂-1" class="headerlink" title="创建工厂"></a>创建工厂</h4><p>创建一个工厂ShapeFactory，它还是提供一个静态方法createShape用来绘制图形，但是传入的参数和实现逻辑与简单工厂模式略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory&#123;</span><br><span class="line">    public static &lt;T extends Shape&gt; T createShape(Class&lt;T&gt; clz)&#123;</span><br><span class="line">        Shape shape = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            shape = (Shape)Class.forName(clz.getName()).newInstance();</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return (T)shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryPatternDemo&#123;</span><br><span class="line">    public static void main(String args)&#123;</span><br><span class="line">        Square square = ShapeFactory.createShape(Square.class);</span><br><span class="line">square.draw();</span><br><span class="line"></span><br><span class="line">Circle circle = ShapeFactory.createShape(Circle.class);</span><br><span class="line">circle.draw();</span><br><span class="line"></span><br><span class="line">Rectangle rect = ShapeFactory.createShape(Rectangle.class);</span><br><span class="line">rect.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">画正方形</span><br><span class="line">画圆</span><br><span class="line">画长方形</span><br></pre></td></tr></table></figure></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>同简单工厂模式相比较，可以看出，如果需要增加一个类型，先创建一个实现工厂接口的子类，然后在客户端调用即可，而不用再去修改工厂的内部逻辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从简单工厂模式中我们可以知道，工厂类中包含了必要的逻辑判断，根据不同的条件来动态实例化相关的类，对客户端来说，如果我们要增加一个产品，那我们就需要在工厂类中添加一个case分支条件，显然这违背了开放封闭原则，即对修改也开放了。而工厂模式就很好地解决了这个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p0w1t27p0.bkt.clouddn.com/limynl/site/factory_pattern_background.jpeg?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工厂模式是Java中最常用的设计模式之一。这种类型的模式属于创建型模式，它提供了一种创建对象的最佳方式，即创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://limynl.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://limynl.site/tags/Java/"/>
    
      <category term="设计模式" scheme="http://limynl.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>String之间的那点儿事</title>
    <link href="http://limynl.site/2017/12/24/string-detail-introduce/"/>
    <id>http://limynl.site/2017/12/24/string-detail-introduce/</id>
    <published>2017-12-24T04:04:07.000Z</published>
    <updated>2017-12-27T01:11:41.976Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="http://p0w1t27p0.bkt.clouddn.com/limynl/site/string_detail_introduce_background.jpeg?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前了解了String、StringBuilder和StringBuffer之间简单的区别，比如String是不可变的，StringBuilder是可变的，StringBuffer是线程安全的等，但对于它们为什么有这些特性却完全蒙蔽，知其然不知其所以然，因此下面将结合最近掌握的，对它们进行详细总结。<br><a id="more"></a></p><h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p>为了更好的理解这三者的关系，下面是它们的关系图：<br><img src="http://p0w1t27p0.bkt.clouddn.com/limynl/site/String_relation.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p><p>从图中可以看出它们都是从CharSequence (<em>是一个接口，表示char值的一个可读序列，此接口对许多不同种类的char序列提供统一的读写访问</em>)扩展而来，<strong>同时String、StringBuilder和StringBuffer的本质都是通过字符数组实现的。</strong></p><h2 id="String详解"><a href="#String详解" class="headerlink" title="String详解"></a>String详解</h2><h3 id="常见创建方式"><a href="#常见创建方式" class="headerlink" title="常见创建方式"></a>常见创建方式</h3><ul><li>方式一：使用关键字new，如：String s1 = new String(“Hello World”);</li><li>方式二：直接定义，如：String s2 = “Hello World”;</li></ul><blockquote><p>当然通过构造函数创建一个String还有很多其他方式，这里就以参数为String的为例</p></blockquote><p>下面通过简单的内存分析图，说明这两种方式的区别：<br><img src="http://p0w1t27p0.bkt.clouddn.com/limynl/sit/String_inner_analysis.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""><br>因此从上面可以看出使用方式一，内存为其分配了两个对象，至于常量池中”Hello World”为什么是一个对象，这就要更深层次的分析了，这里就不做过多的解释；而方式二只创建了一个对象。 因此这里就得出了平时的结论：<br>&emsp;&emsp;1、当需要创建String字符串时，推荐使用方式二的形式，因为使用方式一增大堆内存的消耗；<br>&emsp;&emsp;2、它们之间的“==”关系：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TestString&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String str1 = new String(<span class="string">"Hello World"</span>);</span><br><span class="line">        String str2 = <span class="string">"Hello World"</span>;</span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;当然结果为：false，因为str1、str2不是引用的同一个对象。<br>&emsp;&emsp;3、从图中可以看出String的内部通过char[] value进行管理的，因此String的本质是字符数组。</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br></pre></td></tr></table></figure><ul><li>String被final修饰，说明该类不能被继承；</li><li>实现Serializable，说明可以序列化和反序列化；</li><li>实现Comparable，说明可以进行自定义的字符串比较；</li><li>实现CharSequence，说明利用CharSequence可以实现读写方式。</li></ul><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>源码中可以看见这样一个成员变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//存储字符串中元素的字符数组</span><br><span class="line">private final char value[];</span><br></pre></td></tr></table></figure></p><ul><li>该成员变量是一个字符数组表明，String的本质就是一个字符数组，通过这个字符数组来存储字符内容；</li><li>该字符数组被final修饰，而且value是引用变量，因此可以知道一旦被初始化，即指向内存中一个数组，就不能再指向别的数组了；</li><li>看到这里我们就可以得出结论：<strong>String是不可变的！</strong><br><strong>注意：String不可变是指其内容不能被修改，但是其引用还是可以指向其他内容。</strong>   </li></ul><p>&emsp;&emsp;比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="string">"abc"</span>;</span><br><span class="line">String s4 = <span class="string">"def"</span>;</span><br><span class="line">s3 = s4;</span><br><span class="line">System.out.println(s3);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;因此输出结果为：def</p><p>&emsp;&emsp;这里拿图说话 ☟：<br><img src="http://p0w1t27p0.bkt.clouddn.com/String_not_change.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""><br>&emsp;&emsp;因此从图可知，s3的原来所引用的对象内容确实没有改变，改变的仅仅是s3引用的对象。   </p><p>&emsp;&emsp;⊙(・◇・)？   思考：s3所引用的对象内容到底可不可改变<br>&emsp;&emsp;&emsp;&emsp;我们都知道对象引用，引用的是对象的地址，它根本就不知道对象的实际内容，因此如果String类中如果提供一个可以修改value字符串数组内容的方法，那么String就变成可修改的了，因此实际上String没有这么一个方法。实际上也不应该提供这么一个方法，否则String类就没有意义了。</p><h4 id="常用方法介绍"><a href="#常用方法介绍" class="headerlink" title="常用方法介绍"></a>常用方法介绍</h4><p>上面详细介绍了String类的特性，下面对其几个常用方法进行简要分析，以此对String类的相关特性进一步了解：</p><h5 id="1、构造方法："><a href="#1、构造方法：" class="headerlink" title="1、构造方法："></a>1、构造方法：</h5><p>&emsp;&emsp;(1)、无参构造函数：会创建一个空的字符序列，因为字符串是不可变的，所以没必要使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="function"><span class="title">String</span></span>() &#123;</span><br><span class="line">    this.value = new char[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;(2)、String为参数的构造函数：这个构造方法会产生两个字符串对象，用来初始化一个和输入参数具有相同字符序列的字符串对象，换句话说，新建的这个字符串对象是传入的字符串参数对象的一份副本，除非是明确地需要使用字符串复制功能，否则由于字符串常量值是不可变的，这个构造函数是没有必要使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String(String original) &#123;</span><br><span class="line">    this.value = original.value;</span><br><span class="line">    this.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;(3)、将传入的字符数组复制到一个新的字符数组，并将当前对象的value(即this.value)指向它。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String(char value[]) &#123;</span><br><span class="line">    this.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String(char value[], int offset, int count) &#123;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">    this.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;(4)、使用字节数组创建字符串，同时还可以使用指定的解码方式进行解码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String(byte bytes[])</span><br><span class="line">public String(byte bytes[], int offset, int length) // 从offset开始，长度为length 并以默认的 ISO-8859-1 编码转换成字符串</span><br><span class="line">public String(byte bytes[], Charset charset)</span><br><span class="line">public String(byte bytes[], String charsetName)</span><br><span class="line">public String(byte bytes[], int offset, int length, Charset charset)</span><br><span class="line">public String(byte bytes[], int offset, int length, String charsetName)</span><br></pre></td></tr></table></figure><h5 id="2、常用方法："><a href="#2、常用方法：" class="headerlink" title="2、常用方法："></a>2、常用方法：</h5><p>&emsp;&emsp;(1)、字符串截取，创建了一个新数组，因此牺牲了一定的空间性能。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex, int endIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = endIndex - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this</span><br><span class="line">            : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;(2)、比较两个字符串，可以看出是比较的一个一个字符内容，因此两个相同字符串内容的String对象比较，都是true<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (this == anObject) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String) anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            <span class="keyword">while</span> (n-- != 0) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])//对两个字符串中的字符一个一个比较</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>String中还有很多其他方法，具体的自己可以去看看源码，基本上都是字符数组的操作~~~</p><h3 id="扩展：到底创建了几个对象？"><a href="#扩展：到底创建了几个对象？" class="headerlink" title="扩展：到底创建了几个对象？"></a>扩展：到底创建了几个对象？</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>常量池：指的是在编译期被确定，并保存在以编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的==常量==，也包括==字符串常量==。</p><h4 id="情形一"><a href="#情形一" class="headerlink" title="情形一"></a>情形一</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure><p>上面总共创建了一个对象，由于执行到第一行时常量池中并不存在”abc”，故需要创建一个对象，执行到第二行时，由于常量池中存在”abc”，故直接共享常量池中的内容，因此不会创建对象。</p><h4 id="情形二"><a href="#情形二" class="headerlink" title="情形二"></a>情形二</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="built_in">test</span> = <span class="string">"abcdefxyz"</span>;</span><br><span class="line">String s5 = <span class="string">"abc"</span> + <span class="string">"def"</span>;</span><br><span class="line">String s6 = s5 + <span class="string">"xyz"</span>;</span><br><span class="line">System.out.println(<span class="built_in">test</span> == s6);//<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面两句代码各创建了几个对象：<br>&emsp;&emsp;(1)、首先对于String s5 = “abc” + “def”; 一般我们会认为创建了两个对象，即”abc”和”def”，其实不然，由于常量的值在编译时执行“+”就被确定了，因此变量s5在编译时就可以确定为”abcdef”，因此实际上只创建了一个对象，其实这里就是Java中String的一种优化。<br>&emsp;&emsp;(2)、对于String s6 = s5 + “xyz”; 由于s5是一个变量，在编译时它的值并不确定，故并不会实现编译优化，因此就会产生两个对象，即”xyz”和”abcdefxyz”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String <span class="built_in">test</span> = <span class="string">"aaabbb"</span>;</span><br><span class="line">final String s7 = <span class="string">"aaa"</span>;</span><br><span class="line">final String s8 = <span class="string">"bbb"</span>;</span><br><span class="line">String s9 = s7 + s8;</span><br><span class="line">System.out.println(<span class="built_in">test</span> == s9);//<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;(3)、对于上面的String s9 = s7 + s8; 并不产生对象，因为s7、s8均为常量，所以编译时就能确定，编译时就会将常量替换，等同于是s9 = “aaa”+”bbb”，因此不产生新对象。</p><p>结论：    </p><ul><li>使用“+”连接的两个字符串本身就是字面常量字符串时，如果池中存在这样连接后的字符串，则是不会重新创建对象，而是直接引用池中的字符串对象；</li><li>如果“+”连接的两字符串中只要有一个不是字面常量串（即定义过的），是会产生新的字符串对象。</li></ul><h4 id="情形三"><a href="#情形三" class="headerlink" title="情形三"></a>情形三</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//案例一</span><br><span class="line">String s7 = new String(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">for</span>(int i = 0;i &lt; 100;i++)&#123;</span><br><span class="line">    s7 = s7 + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//案例二</span><br><span class="line">String s8 = <span class="string">"def"</span>;</span><br><span class="line"><span class="keyword">for</span>(int i =0;i &lt; 100;i++)&#123;</span><br><span class="line">    s8 = s8 + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此从前面我们可以知道案例一情况下，将会产生102个对象；案例二情况下，将会产生101个对象。因此当我们的程序中需要大量的拼接字符串时，应该使用效率更高的StringBuilder。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>从上面可以看出虽然String不可变，但是总有其好处：    </p><ul><li>由于它的不可变特性，当我们传参数时，使用不可变类不需要去考虑谁可能会修改其内部的值，因此相对较安全；</li><li>由于常量池的作用，对个引用变量可以引用同一个字符串实例，避免频繁创建实例的开销。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>由于文章篇幅较长，因此将分两部分介绍，传送☞  ++深度解析StringBuilder和StringBuffer++</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p0w1t27p0.bkt.clouddn.com/limynl/site/string_detail_introduce_background.jpeg?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前了解了String、StringBuilder和StringBuffer之间简单的区别，比如String是不可变的，StringBuilder是可变的，StringBuffer是线程安全的等，但对于它们为什么有这些特性却完全蒙蔽，知其然不知其所以然，因此下面将结合最近掌握的，对它们进行详细总结。&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://limynl.site/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://limynl.site/tags/Java/"/>
    
      <category term="源码" scheme="http://limynl.site/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(二)之单例模式</title>
    <link href="http://limynl.site/2017/12/15/design-pattern-singleton/"/>
    <id>http://limynl.site/2017/12/15/design-pattern-singleton/</id>
    <published>2017-12-15T15:13:09.000Z</published>
    <updated>2018-01-09T06:56:56.304Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="http://p0w1t27p0.bkt.clouddn.com/singleton_background.jpg?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>单例模式(Singleton Pattern)是Java中最简单的设计模式之一。这种模式设计到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，外部不需要实例化该类的对象。</p><a id="more"></a><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://p0w1t27p0.bkt.clouddn.com/limynl/site/design_singleton_pattern.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/1" alt=""><br>一般单例模式共有六种，单例模式根据实例化对象时机的不同主要分为两种：</p><ul><li>饿汉式：该类型在单例类被加载时候，就实例化一个对象交给自己的引用；</li><li>懒汉式：当需要时才会去加载，并实例化该对象。</li></ul><h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    </span><br><span class="line">    //声明一个私有化静态变量</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    //构造器私有化，避免外部直接创建对象</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //对外提供一个公共的静态方法访问该变量，如果该变量没有对象，则创建</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 该方式在用户第一次调用时初始化，实现了懒加载，但是在多线程环境下不能工作。</p><h3 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式(线程安全)"></a>懒汉式(线程安全)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    </span><br><span class="line">    //声明一个私有化静态变量</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    //构造器私有化，避免外部直接创建对象</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //对外提供一个公共的静态方法访问该变量，如果该变量没有对象，则创建</span><br><span class="line">    //同时使用synchronized保证了线程的安全</span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 该方式具备懒加载，在多线程下能很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，因此该方法不常使用。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    </span><br><span class="line">    //声明私有静态变量，同时创建该对象，因此类加载时该对象就已经存在</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    </span><br><span class="line">    //构造器私有化，避免外部直接创建对象</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //对外提供公共的静态方法访问该对象</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 该方式在类加载时就完成了初始化，因此不具备懒加载，但获取对象的速度快，但是该方式基于类加载机制避免了多线程的同步问题，因此是线程安全的，没有加锁，执行效率会提高</p><h3 id="双重校验方式"><a href="#双重校验方式" class="headerlink" title="双重校验方式"></a>双重校验方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    </span><br><span class="line">    //声明一个私有化静态变量</span><br><span class="line">private volatile static Singleton instance= null;</span><br><span class="line"></span><br><span class="line">//构造器私有化，避免外部直接创建对象</span><br><span class="line">private Singleton()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">if(instance == null)&#123;//当存在该对象时，直接返回该对象，为了提高效率，避免互斥等待</span><br><span class="line">synchronized (Singleton.class) &#123;//保证多线程的安全</span><br><span class="line">if(instance == null)&#123;//确保一个类只有一个对象</span><br><span class="line">instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 注意两个if条件的作用，第一个if是为了避免每次getInstance()都进行不必要的同步，第二个if是为了在instance为null的条件下，创建该类的实例。该方式采用双锁机制，安全且在多线程下能保持高性能，同时该方式也是在需要的时候才去加载，效率高，有很好的懒加载效果。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。同时程序中使用volatile会或多或少的影响性能，但考虑到程序的正确性，牺牲这点性能还是值得的。</p><h3 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"></span><br><span class="line">    //定义一个静态内部类</span><br><span class="line">private static class SingleHolder&#123;</span><br><span class="line">private static Singleton instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//私有化构造函数</span><br><span class="line">private Singleton()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在需要时才去加载</span><br><span class="line">public Singleton getInstance()&#123;</span><br><span class="line">return SingleHolder.instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 当Singleton类加载时，SingleHolder并不会加载，只有在第一次调用getInstance()时，SingleHolder才会加载，因此保证了线程安全和Singleton类的唯一性，同时具备很好的懒加载。该种方式跟双重校验能达到相同效果，但是该方式只适用于静态域的情况，双重校验方式可在实例域需要延迟初始化时使用。</p><h3 id="枚举类型方式"><a href="#枚举类型方式" class="headerlink" title="枚举类型方式"></a>枚举类型方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton&#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     </span><br><span class="line">     public void doSomeThing() &#123;  </span><br><span class="line">        </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，因此不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。但是该种方式，用的比较少，可读性不高。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li><p>上面六种方式，除了枚举类型单例，其余的方式在反序列化情况下会重新创建对象，即将一个单例实例对象从磁盘或者网络写回来时，为了避免这种情况，反序列化操作提供了readResolve方法，这个方法可以让开发人员控制对象的反序列化，因此在上述的几个方法示例中如果要杜绝单例对象被反序列化时重新生成对象，就必须加入如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Object readResolve() thows ObjectStreamException&#123;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面说到序列化时，会产生多个实例，同时在分布式系统、多个类加载器的情况下都会产生多个单例实例。同时使用反射方式，也会得到新的单例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(Singleton.class.getName());  </span><br><span class="line">Constructor ct = c.getDeclaredConstructor();  </span><br><span class="line">ct.setAccessible(true);  </span><br><span class="line">Singleton singleton = (Singleton)ct.newInstance();</span><br></pre></td></tr></table></figure></li></ul><p>这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>一个单例类只能有一个实例；</li><li>单例类必须自己创建自己的唯一实例；</li><li>单例类必须给所有其他对象提供这一实例。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>在内存中只有一个对象，节省内存空间；</li><li>避免频繁的创建销毁对象，可以提高性能；</li><li>避免对共享资源的多重占用；</li><li>可以全局访问。</li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>只能使用单例类提供的getInstance()得到单例对象，不要使用反射，否则将会实例化一个新对象；</li><li>不要做断开单例类对象与类中静态引用的危险操作；</li><li>多线程使用单例使用共享资源时，注意线程安全问题；</li><li>在反序列化时，重写readResolve()方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p0w1t27p0.bkt.clouddn.com/singleton_background.jpg?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;单例模式(Singleton Pattern)是Java中最简单的设计模式之一。这种模式设计到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，外部不需要实例化该类的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://limynl.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://limynl.site/tags/Java/"/>
    
      <category term="设计模式" scheme="http://limynl.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(一)之概述</title>
    <link href="http://limynl.site/2017/12/15/design-pattern-summary/"/>
    <id>http://limynl.site/2017/12/15/design-pattern-summary/</id>
    <published>2017-12-15T15:03:47.000Z</published>
    <updated>2017-12-26T08:23:31.993Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="http://p0w1t27p0.bkt.clouddn.com/limynl/site/about.jpg?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设计模式是一套被反复使用的、多数人知晓的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编制真正工程化，它是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。<br><a id="more"></a></p><h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这些设计模式提供了一种在创建对象的同时隐藏其创建逻辑的方式，而不是直接使用new运算符直接实例化对应的对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。具体有以下几种：</p><ul><li><a href="http://limynl.site/2017/12/26/design-pattern-factory/">工厂模式</a></li><li>抽象工厂模式</li><li><a href="http://limynl.site/2017/12/15/design-pattern-singleton/">单例模式</a></li><li>建造者模式</li><li>原型模式</li></ul><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>该类设计模式关注类和对象的组合，是一种使用继承和定义接口以获取新功能的方式。具体有以下几种：：</p><ul><li>适配器模式</li><li>桥接模式</li><li>过滤器模式</li><li>组合模式</li><li>装饰器模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>该类设计模式特别关注对象之间的通信。具体有以下几种：</p><ul><li>责任链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>空对象模式</li><li>策略模式</li><li>模板模式</li><li>访问者模式</li></ul><h2 id="设计六大原则"><a href="#设计六大原则" class="headerlink" title="设计六大原则"></a>设计六大原则</h2><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><h4 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h4><p>&emsp;&emsp;就一个类而言，引起他的变化应该仅有一个，即一个类只负责一项职责。</p><h4 id="解读："><a href="#解读：" class="headerlink" title="解读："></a>解读：</h4><p>&emsp;&emsp;这句话的含义就是不要让一个类承担过多的职责，如果一个类承担的职责过多，就等于将这些职责耦合在一起，一个职责的变化可能会引起这个类中其他职责的变化，甚至会削弱或抑制这个类完成其他职责的能力，以致当这个类中的某个职责发生变化时，设计会遭到破坏。<br>&emsp;&emsp;就像之前做Android的时候，在一个Activity中既要关注界面的变化、又要对数据进行处理，以致于如果这个Activity要实现的功能比较复杂的话，那么这个Activity类中的代码是比较臃肿的，导致后期维护时，对于他人来说是比较蛋疼的，修改了一个地方可能会引起其他地方相应作出修改，这样就会导致引起这个Activity变化原因过多。因此也就背离了单一职责原则的含义。</p><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>&emsp;&emsp;1、单一职责原则降低了类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多；<br>&emsp;&emsp;2、它提高类的可读性，提高系统的可维护性；<br>&emsp;&emsp;3、让变更引起的风险降低，变更是必然的，如果单一职责原则遵守好，当修改一个功能时，可以显著降低对其他功能的影响。</p><h3 id="2、里氏替换原则"><a href="#2、里氏替换原则" class="headerlink" title="2、里氏替换原则"></a>2、里氏替换原则</h3><h4 id="含义：-1"><a href="#含义：-1" class="headerlink" title="含义："></a>含义：</h4><p>&emsp;&emsp;所有使用基类的地方必须能透明地使用其子类的对象。</p><h4 id="解读：-1"><a href="#解读：-1" class="headerlink" title="解读："></a>解读：</h4><p>&emsp;&emsp;在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，即使用基类的地方一定能够使用其子类。反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。<br>&emsp;&emsp;里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。<br>&emsp;&emsp;例如在一个邮件系统中，用户分为普通用户可VIP用户，但是这两种类型都具有发邮件的功能，因此相应的类图为：<img src="http://p0w1t27p0.bkt.clouddn.com/limynl/site/commer_vip_customer1.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="">但是我们在实现在，无论是普通用户还是VIP用户，发邮件的过程都是相同的，因此两个send方法中的代码将会重复，如果以后还会增加其他类型的用户呢？那么这个系统的代码将会很冗余。因此通过里氏替换原则，可以对其进行如下修改:<img src="http://p0w1t27p0.bkt.clouddn.com/limynl/site/commer_vip_customer2.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="">这里增加了一个抽象类，作为所有类型的基类，发送类EmailSender类针对抽象客户类Customer编程，因此我们用基类类型来对对象进行定义，当运行时再确定其子类类型，从而实现用子类对象来代替基类对象。同时如果还需要增加其他类型的话，只需要继承Customer类就行。</p><h4 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h4><p>&emsp;&emsp;使用里氏替换原则需要注意以下几点：<br>&emsp;&emsp;1、子类的所有非私有方法应该在基类中声明，或子类必须实现父类中声明的方法(<strong><em>子类可以扩展基类的功能，但不能改变基类原有的功能</em></strong>)。即为了保证系统的扩展性，在程序中通常使用基类来进行定义，如果一个方法只存在子类中，在子类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。<br>&emsp;&emsp;2、在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。这里也体现了里氏代换原则是开闭原则的具体实现手段之一。<br>&emsp;&emsp;3、Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</p><h3 id="3、依赖倒置原则"><a href="#3、依赖倒置原则" class="headerlink" title="3、依赖倒置原则"></a>3、依赖倒置原则</h3><h4 id="含义：-2"><a href="#含义：-2" class="headerlink" title="含义："></a>含义：</h4><p>&emsp;&emsp;高层模块不应该依赖底层模块，两者都应该依赖其抽象。即：抽象不应该依赖细节，细节应该依赖抽象。</p><h4 id="解读：-2"><a href="#解读：-2" class="headerlink" title="解读："></a>解读：</h4><p>&emsp;&emsp;在Java中，抽象就是指接口或抽象类，两者是不能直接被实例化的，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成，而细节就是实现类，实现接口或继承抽象类而产生的就是细节。而高层模块就是调用者，底层模块就是具体实现类。<br>&emsp;&emsp;依赖倒置原则在Java中的表现就是：模块间通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合，那么当修改时，就会同时修改依赖者代码，这样限制了可扩展性。<br>&emsp;&emsp;例如下面这个例子：一个学生应该具有学习多门课程的能力。比如他喜欢学习语文。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class StudyChinese&#123;</span><br><span class="line">    public String <span class="function"><span class="title">ability</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"我能学习语文!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student&#123;</span><br><span class="line">    public void study(StudyChinese chinese)&#123;</span><br><span class="line">        System.out.println(chinese.ability());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.study(new StudyChinese());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时可以看出该学生能够学语文，但是还应该能够学习数学、英语等，要实现这些那么我们应该将Student不断进行修改，显然这样操作的话，各个类之间的耦合度就太高了。因此我们可以引入一个接口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IStudy&#123;</span><br><span class="line">    public String ability();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样该学生就不止会学语文了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class StudyChinese impliments IStudy&#123;</span><br><span class="line">    public String <span class="function"><span class="title">ability</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"我能学习语文!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StudyMath impliments IStudy&#123;</span><br><span class="line">    public String <span class="function"><span class="title">ability</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"我能学习数学!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student&#123;</span><br><span class="line">    public void study(IStudy study)&#123;</span><br><span class="line">        System.out.println(study.ability());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.study(new StudyChinese());</span><br><span class="line">        student.study(new StudyMath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此现在只需要修改Client，就能扩展该学生的知识，学习相应的课程。从而就不用再去修改Student类了。</p><h4 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h4><p>&emsp;&emsp;1、底层模块尽量都要有接口或抽象类；<br>&emsp;&emsp;2、形参类型尽量为接口或抽象类类型，即遵循里氏替换原则。<br>&emsp;&emsp;3、传递依赖关系有三种方式，分别为：接口传递、构造方法传递、setter方法传递，以上的例子使用的是接口传递。<br>&emsp;&emsp;4、通过上面的例子可以看出依赖倒置原则给并行开发带来了极大的便利，先前Student类和StudyChinese类耦合在一起，就是说Student类必须等StudyChinese类完成后才能编码；而优化后的程序可以看出St类与StudyChinese、StudyMath类没有任何直接关系，因此将提高开发效率。</p><h3 id="4、接口隔离原则"><a href="#4、接口隔离原则" class="headerlink" title="4、接口隔离原则"></a>4、接口隔离原则</h3><h4 id="含义：-3"><a href="#含义：-3" class="headerlink" title="含义："></a>含义：</h4><p>&emsp;&emsp;客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p><h4 id="解读：-3"><a href="#解读：-3" class="headerlink" title="解读："></a>解读：</h4><p>&emsp;&emsp;建立接口时，应该建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。<br>&emsp;&emsp;就如下面的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">interface I&#123;</span><br><span class="line">    public void method1();  </span><br><span class="line">    public void method2();  </span><br><span class="line">    public void method3();  </span><br><span class="line">    public void method4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对于类A只需要method1、m但因为实现接口I，因此也要实现不需要的method3、method4，即使这两个方法的方法体为空。</span><br><span class="line">public class A impliments I&#123;</span><br><span class="line">    public void <span class="function"><span class="title">method1</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现方法一"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="function"><span class="title">method2</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现方法二"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="function"><span class="title">method3</span></span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="function"><span class="title">method4</span></span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//类B与A相识，为了实现接口I也要实现不需要的method1、method2</span><br><span class="line">public class B impliments I&#123;</span><br><span class="line">    public void <span class="function"><span class="title">method1</span></span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="function"><span class="title">method2</span></span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="function"><span class="title">method3</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现方法三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="function"><span class="title">method4</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现方法四"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此从上面可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用，实现类中都必须去实现这些方法。因此我们可以对接口进行拆分：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface I1&#123;</span><br><span class="line">    public void method1();  </span><br><span class="line">    public void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface I2&#123;</span><br><span class="line">    public void method3();  </span><br><span class="line">    public void method4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class A impliments I1&#123;</span><br><span class="line">    public void <span class="function"><span class="title">method1</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现方法一"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="function"><span class="title">method2</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现方法二"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B impliments I2&#123;</span><br><span class="line">    public void <span class="function"><span class="title">method3</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现方法三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="function"><span class="title">method4</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现方法四"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><h4 id="说明：-3"><a href="#说明：-3" class="headerlink" title="说明："></a>说明：</h4><p>&emsp;&emsp;1、接口应该尽量小，但是要有限度，因为接口过小的话，就会造成接口数量过多，使设计复杂化。因此要掌握好这个“度”应该在平时对相应问题进行仔细思考。<br>&emsp;&emsp;2、要建立最小的依赖关系，应该为依赖接口的类定制服务，即之暴露给调用的类它需要的方法，将不需要的方法隐藏起来。<br>&emsp;&emsp;3、注意与单一职责原则相区别：<br>&emsp;&emsp;&emsp;(1)、单一职责原则原注重的是职责，而接口隔离原则注重对接口依赖的隔离；<br>&emsp;&emsp;&emsp;(2)、单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><h3 id="5、迪米特法则"><a href="#5、迪米特法则" class="headerlink" title="5、迪米特法则"></a>5、迪米特法则</h3><h4 id="含义：-4"><a href="#含义：-4" class="headerlink" title="含义："></a>含义：</h4><p>&emsp;&emsp;一个软件实体应当尽可能少的与其他实体发生相互作用，又叫做最少知道原则。</p><h4 id="解读：-4"><a href="#解读：-4" class="headerlink" title="解读："></a>解读：</h4><p>&emsp;&emsp;通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。<br>&emsp;&emsp;迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。<br>&emsp;&emsp;例如下面的例子：当ClassBase有动作时时，和它有关联的类ClassB、ClassC、ClassD等都将发生改变。<br><img src="http://p0w1t27p0.bkt.clouddn.com/limynl/site/dimite1.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""><br>因此从上面可以看见由于类之间的交互关系复杂，导致在该系统中增加新的对象时需要修改与之交互的其它类的源代码，系统扩展性较差，也不便于增加和删除新对象。<br>&emsp;&emsp;下面将引入一个专门用于控制对象间交互的中介类(Agent)来降低各对象之间的耦合度。引入中间类之后，相关对象之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其它对象的调用。当需要增加或删除新的对象时，只需修改中间类即可，无须修改新增对象或已有对象的源代码。<img src="http://p0w1t27p0.bkt.clouddn.com/limynl/site/dimite2.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt=""></p><h4 id="说明：-4"><a href="#说明：-4" class="headerlink" title="说明："></a>说明：</h4><p>&emsp;&emsp;1、在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；<br>&emsp;&emsp;2、在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；<br>&emsp;&emsp;3、在类的设计上，只要有可能，一个类型应当设计成不变类；<br>&emsp;&emsp;4、在对其他类的引用上，一个对象对其他对象的引用应当降到最低。<br>&emsp;&emsp;5、迪米特法则的另外一层含义是：<strong>只与直接的朋友通信</strong>。直接朋友指：<br>&emsp;&emsp; (1)、当前对象本身(this);<br>&emsp;&emsp; (2)、以参量形式传入到当前对象方法中的对象;<br>&emsp;&emsp; (3)、当前对象的实例变量直接引用的对象;<br>&emsp;&emsp; (4)、当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友;<br>&emsp;&emsp; (5)、当前对象所创建的对象。<br>&emsp;&emsp; 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”。</p><h3 id="6、开放封闭原则"><a href="#6、开放封闭原则" class="headerlink" title="6、开放封闭原则"></a>6、开放封闭原则</h3><h4 id="含义：-5"><a href="#含义：-5" class="headerlink" title="含义："></a>含义：</h4><p>&emsp;&emsp;多扩展开放、对修改关闭，即类、函数等等应该能够扩展，而不是去修改。</p><h4 id="解读：-5"><a href="#解读：-5" class="headerlink" title="解读："></a>解读：</h4><p>&emsp;&emsp;从上面的含义我们知道该原则有两方面的意思，一个就是对于扩展是开放的，另一个就是对于修改是封闭的。就是说当程序需要进行扩展的时候，不能去修改原有的代码，实现一个热插拔的效果。因为在实际开发中需求的改变在所难免，但是需求一变就把所涉及的类重新改一遍这个显然很头疼，因此我们在设计程序时，要针对需求尽量保证代码的相对稳定。简言之，就是为了使程序的扩展性好，易于维护和升级。<br>&emsp;&emsp;其实从上面的叙述来说，开放封闭有点模糊，尽管知道要扩展开放、对修改关闭，但是如何才能做到呢？其实我们经过前面五大原则可以发现，要实现开放封闭原则，无非就是<strong>用抽象构建框架，用实现扩展细节</strong>，因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。</p><h4 id="说明：-5"><a href="#说明：-5" class="headerlink" title="说明："></a>说明：</h4><p>&emsp;&emsp; 1、里氏替换原则开放封闭原则的实现提供保证；<br>&emsp;&emsp; 2、封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态一般将其封装为一个抽象，但是拒绝滥用抽象，只将经常变化的部分进行抽象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于上面的六大原则可概括为：</p><ul><li>单一职责原则: 实现类要职责单一;</li><li>里氏替换原则: 不要破坏继承体系;</li><li>依赖倒置原则: 使用面向接口编程;</li><li>接口隔离原则: 设计接口精简单一;</li><li>迪米特法则:&emsp; 类与类要降低耦合。</li></ul><p>对于这六大原则的使用，我们应该尽量合理地遵守，也不用刻意去遵守，否则将会遵守过渡。对于具体如何使用，就要靠平时的学习积累，以及依照个人经验来定，当然经验的好坏，将决定整个设计的质量。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>提高自己的方法有很多，将自己学过的以这种方式记录下来，希望自己有所收获，同时希望能够帮助需要帮助的人~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p0w1t27p0.bkt.clouddn.com/limynl/site/about.jpg?imageView2/0/q/75|watermark/2/text/aHR0cDovL2xpbXlubC5zaXRl/font/5b6u6L2v6ZuF6buR/fontsize/440/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编制真正工程化，它是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://limynl.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://limynl.site/tags/Java/"/>
    
      <category term="设计模式" scheme="http://limynl.site/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
